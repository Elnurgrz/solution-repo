{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Home"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Motion: Projectile motion can be analyzed using Newton's laws of motion. Assuming no air resistance, the motion can be decomposed into horizontal and vertical components: Equations of Motion: Horizontal: $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical: $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time. Time of Flight: Setting \\( y(t) = 0 \\) to find the total flight time: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range Formula: The horizontal range \\( R \\) is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the range is maximized at \\( \\theta = 45^\\circ \\) , assuming other parameters remain constant. 2. Analysis of the Range Influence of Initial Conditions Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) . Graphical Representation Python codes to demonstrate how the range changes: import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() 3. Practical Applications -Sports: Athletes and coaches use principles of projectile motion to optimize performance in events like javelin throwing, shot put, and long jump, where launch angles and velocities are critical. Engineering: In ballistics and military applications, understanding projectile trajectories is essential for designing artillery, missiles, and other projectile-based systems. Astrophysics: Astronomers apply these principles to model the trajectories of celestial bodies, such as comets and asteroids, and to plan space missions. 4. Implementation To analyze scenarios involving air resistance, we can incorporate drag forces into our model. This leads to differential equations that require numerical methods, such as the Runge-Kutta method, for solution. Example: Adding Air Resistance The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions. 5. Limitations and Further Considerations Air resistance - Causes asymmetry and reduces range. Uneven terrain - Requires solving for complex boundary conditions. Wind effects - Affects trajectory unpredictably. Conclusion Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions. - Initial velocity ( \\(v_0\\) ): The range is proportional to the square of the initial velocity. Increasing \\(v_0\\) significantly increases the range. - Gravitational acceleration ( \\(g\\) ): The range is inversely proportional to the gravitational acceleration. Higher \\(g\\) reduces the range. - Launch angle ( \\(\\theta\\) ): The range is maximized at \\(\\theta = 45^\\circ\\) , and it is symmetric around this angle.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Governing Equations of Motion: Projectile motion can be analyzed using Newton's laws of motion. Assuming no air resistance, the motion can be decomposed into horizontal and vertical components:","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal: $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical: $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time.","title":"Equations of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\( y(t) = 0 \\) to find the total flight time: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"The horizontal range \\( R \\) is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the range is maximized at \\( \\theta = 45^\\circ \\) , assuming other parameters remain constant.","title":"Range Formula:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","text":"Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) .","title":"Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","text":"Python codes to demonstrate how the range changes: import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"-Sports: Athletes and coaches use principles of projectile motion to optimize performance in events like javelin throwing, shot put, and long jump, where launch angles and velocities are critical. Engineering: In ballistics and military applications, understanding projectile trajectories is essential for designing artillery, missiles, and other projectile-based systems. Astrophysics: Astronomers apply these principles to model the trajectories of celestial bodies, such as comets and asteroids, and to plan space missions.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"To analyze scenarios involving air resistance, we can incorporate drag forces into our model. This leads to differential equations that require numerical methods, such as the Runge-Kutta method, for solution.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-air-resistance","text":"The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions.","title":"Example: Adding Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","text":"Air resistance - Causes asymmetry and reduces range. Uneven terrain - Requires solving for complex boundary conditions. Wind effects - Affects trajectory unpredictably.","title":"5. Limitations and Further Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions. - Initial velocity ( \\(v_0\\) ): The range is proportional to the square of the initial velocity. Increasing \\(v_0\\) significantly increases the range. - Gravitational acceleration ( \\(g\\) ): The range is inversely proportional to the gravitational acceleration. Higher \\(g\\) reduces the range. - Launch angle ( \\(\\theta\\) ): The range is maximized at \\(\\theta = 45^\\circ\\) , and it is symmetric around this angle.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1 Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small Angles For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics. 2. Analysis of Dynamics Influence of System Parameters Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge. Transition to Chaos By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary. 3. Practical Applications The forced damped pendulum model has applications in various real-world systems: Energy Harvesting Devices : Designing efficient devices to convert ambient mechanical vibrations into electrical energy by optimizing resonance conditions. Suspension Bridges : Understanding and mitigating oscillations in suspension bridges to prevent structural failures due to resonance and chaotic vibrations. Electrical Circuits : Modeling and analyzing the behavior of driven RLC circuits, which exhibit analogous dynamics to the forced damped pendulum. 4. Implementation Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # damping coefficient g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) # simulation time t_eval = np.linspace(0, 50, 1000) # time steps # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) # Plot results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time. 5. Limitations and Extensions Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Implementing nonlinear damping models (e.g., air drag proportional to velocity squared) to more accurately represent energy dissipation. Investigating the effects of non-sinusoidal driving forces to model more complex external perturbations. Studying coupled pendulum systems to explore synchronization phenomena and complex interactions between multiple oscillators. 6. Conclusion The forced damped pendulum demonstrates a wide range of dynamical behaviors, from simple harmonic motion to complex chaotic motion. By adjusting damping, forcing amplitude, and driving frequency, we can explore fundamental concepts like resonance, stability, and chaos, which have significant implications in both theoretical physics and practical engineering applications","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angles","text":"For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters.","title":"Approximate Solutions for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-system-parameters","text":"Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge.","title":"Influence of System Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model has applications in various real-world systems: Energy Harvesting Devices : Designing efficient devices to convert ambient mechanical vibrations into electrical energy by optimizing resonance conditions. Suspension Bridges : Understanding and mitigating oscillations in suspension bridges to prevent structural failures due to resonance and chaotic vibrations. Electrical Circuits : Modeling and analyzing the behavior of driven RLC circuits, which exhibit analogous dynamics to the forced damped pendulum.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # damping coefficient g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) # simulation time t_eval = np.linspace(0, 50, 1000) # time steps # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) # Plot results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Implementing nonlinear damping models (e.g., air drag proportional to velocity squared) to more accurately represent energy dissipation. Investigating the effects of non-sinusoidal driving forces to model more complex external perturbations. Studying coupled pendulum systems to explore synchronization phenomena and complex interactions between multiple oscillators.","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum demonstrates a wide range of dynamical behaviors, from simple harmonic motion to complex chaotic motion. By adjusting damping, forcing amplitude, and driving frequency, we can explore fundamental concepts like resonance, stability, and chaos, which have significant implications in both theoretical physics and practical engineering applications","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation 1.1 Kepler\u2019s Third Law Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, the relationship can be derived by combining Newton's law of gravitation with the concept of centripetal force. Newton's law of gravitation states that the gravitational force between two masses is proportional to the product of their masses and inversely proportional to the square of the distance between them. The centripetal force is the force that keeps an object moving in a circular path and is directed toward the center of the orbit. Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) . 1.2 Implications in Astronomy Calculating Planetary Mass: Using the period and radius of a planet's moon, we can calculate the mass of the planet. Estimating Orbital Radius: If the period of a planet's orbit around the Sun is known, we can estimate its orbital radius. Designing Satellite Orbits: This principle is used to create stable satellite orbits around Earth and other celestial bodies. 2. Real-World Examples The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets. 3. Computational Model The following Python script simulates verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Calculates the time taken for an object to complete an orbit at various distances. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship. 4. Extensions and Limitations Elliptical Orbits: Kepler\u2019s Third Law still holds, but instead of a fixed radius, the semi-major axis determines the orbital period. Relativistic Effects: In regions with intense gravity, such as near massive stars or black holes, general relativity introduces corrections to Kepler\u2019s laws. External Forces: Gravitational influences from other celestial bodies can cause deviations in orbits over long periods, leading to phenomena like precession and orbital resonance. 5. Conclusion Kepler\u2019s Third Law establishes a crucial connection between orbital period and radius, allowing precise calculations in celestial mechanics. This principle is essential in astronomy, satellite navigation, and space mission planning.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-keplers-third-law","text":"Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, the relationship can be derived by combining Newton's law of gravitation with the concept of centripetal force. Newton's law of gravitation states that the gravitational force between two masses is proportional to the product of their masses and inversely proportional to the square of the distance between them. The centripetal force is the force that keeps an object moving in a circular path and is directed toward the center of the orbit. Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) .","title":"1.1 Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-implications-in-astronomy","text":"Calculating Planetary Mass: Using the period and radius of a planet's moon, we can calculate the mass of the planet. Estimating Orbital Radius: If the period of a planet's orbit around the Sun is known, we can estimate its orbital radius. Designing Satellite Orbits: This principle is used to create stable satellite orbits around Earth and other celestial bodies.","title":"1.2 Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets.","title":"2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-model","text":"The following Python script simulates verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Calculates the time taken for an object to complete an orbit at various distances. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extensions-and-limitations","text":"Elliptical Orbits: Kepler\u2019s Third Law still holds, but instead of a fixed radius, the semi-major axis determines the orbital period. Relativistic Effects: In regions with intense gravity, such as near massive stars or black holes, general relativity introduces corrections to Kepler\u2019s laws. External Forces: Gravitational influences from other celestial bodies can cause deviations in orbits over long periods, leading to phenomena like precession and orbital resonance.","title":"4. Extensions and Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler\u2019s Third Law establishes a crucial connection between orbital period and radius, allowing precise calculations in celestial mechanics. This principle is essential in astronomy, satellite navigation, and space mission planning.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Theoretical Foundation Definition of Cosmic Velocities Cosmic velocities define the minimum speeds needed for different space motions: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun. 2. Mathematical Derivations and Parameters Affecting Velocities These cosmic velocities depend on the mass of the celestial body and the radius of the body or orbit. As such, the escape velocity increases with the mass of the body and decreases with the radius. Effect of Mass: As the mass of the body increases, the gravitational pull strengthens, requiring higher velocities to escape or orbit. Larger celestial bodies, such as Jupiter or the Sun, have much higher escape velocities compared to smaller bodies like the Moon. Effect of Radius: The farther you are from the center of a body, the weaker the gravitational force, which reduces the required velocity. For example, an object at a higher altitude above Earth's surface will need a lower velocity to escape. 3. Python Script for Calculations and Visualization Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance to sun in meters) bodies = { \"Earth\": {\"mass\": 5.97e24, \"radius\": 6.37e6, \"distance_to_sun\": 1.496e11}, \"Mars\": {\"mass\": 6.42e23, \"radius\": 3.39e6, \"distance_to_sun\": 2.279e11}, \"Jupiter\": {\"mass\": 1.90e27, \"radius\": 6.99e7, \"distance_to_sun\": 7.785e11}, } # Function to calculate the first cosmic velocity (circular orbit) def first_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (escape from the star's gravitational influence) def third_velocity(mass, radius, distance_to_sun, second_velocity_earth): return np.sqrt(2 * G * mass / radius + (second_velocity_earth**2) / 2) # Dictionary to store the velocities for each body velocities = {} # Calculate the first and second cosmic velocities for each celestial body for body, data in bodies.items(): velocities[body] = { \"v1\": first_velocity(data[\"mass\"], data[\"radius\"]), \"v2\": second_velocity(data[\"mass\"], data[\"radius\"]), } # Calculate the third cosmic velocity for each celestial body for body, data in bodies.items(): second_velocity_earth = velocities[\"Earth\"][\"v2\"] if body == \"Earth\" else 0 velocities[body][\"v3\"] = third_velocity(data[\"mass\"], data[\"radius\"], data[\"distance_to_sun\"], second_velocity_earth) # Prepare data for plotting labels = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] v3_values = [velocities[body][\"v3\"] for body in labels] # Plotting the velocities x = np.arange(len(labels)) # X-axis positions for each body fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.2, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, 0.2, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + 0.2, v3_values, 0.2, label='Third Cosmic Velocity (v3)', color='red') # Adding labels and title ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() # Display the plot plt.tight_layout() plt.show() This script: Calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Visualizes a comparison of these velocities using a bar chart to illustrate the differences for each celestial body. 4. Importance in Space Exploration Escape Velocity: The escape velocity is essential for launching spacecraft and satellites. For instance, Earth\u2019s escape velocity is approximately 11.2 km/s, meaning a spacecraft needs this speed to break free from Earth's gravity without further propulsion. For interplanetary missions, the second cosmic velocity helps in launching spacecraft to other planets, such as Mars, where the escape velocity is much lower than Earth's. Orbital Velocity: The orbital velocity is critical for satellites. A satellite needs to achieve a specific orbital velocity to stay in a stable orbit around a planet, like Earth. This velocity ensures that the satellite's centrifugal force balances the gravitational pull from the planet. Solar Escape Velocity: The third cosmic velocity is particularly relevant for missions aimed at escaping not just a planet\u2019s gravity but the entire solar system, enabling spacecraft like Voyager 1 to leave the solar system and head into interstellar space. 5. Conclusion Understanding cosmic velocities is fundamental for space exploration, from launching satellites to planning interplanetary missions and even considering future interstellar travel. By calculating and visualizing these velocities for different celestial bodies, we can better understand the challenges of escaping gravitational forces and venturing into space.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definition-of-cosmic-velocities","text":"Cosmic velocities define the minimum speeds needed for different space motions: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun.","title":"Definition of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters-affecting-velocities","text":"These cosmic velocities depend on the mass of the celestial body and the radius of the body or orbit. As such, the escape velocity increases with the mass of the body and decreases with the radius. Effect of Mass: As the mass of the body increases, the gravitational pull strengthens, requiring higher velocities to escape or orbit. Larger celestial bodies, such as Jupiter or the Sun, have much higher escape velocities compared to smaller bodies like the Moon. Effect of Radius: The farther you are from the center of a body, the weaker the gravitational force, which reduces the required velocity. For example, an object at a higher altitude above Earth's surface will need a lower velocity to escape.","title":"2. Mathematical Derivations and Parameters Affecting Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-script-for-calculations-and-visualization","text":"Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance to sun in meters) bodies = { \"Earth\": {\"mass\": 5.97e24, \"radius\": 6.37e6, \"distance_to_sun\": 1.496e11}, \"Mars\": {\"mass\": 6.42e23, \"radius\": 3.39e6, \"distance_to_sun\": 2.279e11}, \"Jupiter\": {\"mass\": 1.90e27, \"radius\": 6.99e7, \"distance_to_sun\": 7.785e11}, } # Function to calculate the first cosmic velocity (circular orbit) def first_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (escape from the star's gravitational influence) def third_velocity(mass, radius, distance_to_sun, second_velocity_earth): return np.sqrt(2 * G * mass / radius + (second_velocity_earth**2) / 2) # Dictionary to store the velocities for each body velocities = {} # Calculate the first and second cosmic velocities for each celestial body for body, data in bodies.items(): velocities[body] = { \"v1\": first_velocity(data[\"mass\"], data[\"radius\"]), \"v2\": second_velocity(data[\"mass\"], data[\"radius\"]), } # Calculate the third cosmic velocity for each celestial body for body, data in bodies.items(): second_velocity_earth = velocities[\"Earth\"][\"v2\"] if body == \"Earth\" else 0 velocities[body][\"v3\"] = third_velocity(data[\"mass\"], data[\"radius\"], data[\"distance_to_sun\"], second_velocity_earth) # Prepare data for plotting labels = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] v3_values = [velocities[body][\"v3\"] for body in labels] # Plotting the velocities x = np.arange(len(labels)) # X-axis positions for each body fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.2, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, 0.2, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + 0.2, v3_values, 0.2, label='Third Cosmic Velocity (v3)', color='red') # Adding labels and title ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() # Display the plot plt.tight_layout() plt.show() This script: Calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Visualizes a comparison of these velocities using a bar chart to illustrate the differences for each celestial body.","title":"3. Python Script for Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-importance-in-space-exploration","text":"Escape Velocity: The escape velocity is essential for launching spacecraft and satellites. For instance, Earth\u2019s escape velocity is approximately 11.2 km/s, meaning a spacecraft needs this speed to break free from Earth's gravity without further propulsion. For interplanetary missions, the second cosmic velocity helps in launching spacecraft to other planets, such as Mars, where the escape velocity is much lower than Earth's. Orbital Velocity: The orbital velocity is critical for satellites. A satellite needs to achieve a specific orbital velocity to stay in a stable orbit around a planet, like Earth. This velocity ensures that the satellite's centrifugal force balances the gravitational pull from the planet. Solar Escape Velocity: The third cosmic velocity is particularly relevant for missions aimed at escaping not just a planet\u2019s gravity but the entire solar system, enabling spacecraft like Voyager 1 to leave the solar system and head into interstellar space.","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-conclusion","text":"Understanding cosmic velocities is fundamental for space exploration, from launching satellites to planning interplanetary missions and even considering future interstellar travel. By calculating and visualizing these velocities for different celestial bodies, we can better understand the challenges of escaping gravitational forces and venturing into space.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Theoretical Part Types of Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory): If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory): If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory): If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion. 2. Mathematical Analysis Equations of Motion The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations. 3. Numerical Method: The following Python script calculates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6371000 # Radius of Earth (m) # Initial conditions (position, velocity) # Example: Launching at a height of 100 km above Earth's surface with horizontal velocity initial_position = np.array([R_earth + 100000, 0]) # [x, y] in meters (100 km above Earth) initial_velocity = np.array([0, 7500]) # Horizontal velocity in m/s # Time parameters dt = 1 # Time step (s) total_time = 5000 # Total time of simulation (s) num_steps = total_time // dt # Arrays to store position and velocity data positions = np.zeros((num_steps, 2)) velocities = np.zeros((num_steps, 2)) # Initial conditions positions[0] = initial_position velocities[0] = initial_velocity # Numerical integration (Euler's method) for i in range(1, num_steps): # Calculate the gravitational force r = np.linalg.norm(positions[i-1]) # Distance from Earth's center force = -G * M * positions[i-1] / r**3 # Gravitational force vector (N) # Update velocity and position velocities[i] = velocities[i-1] + force * dt # v = v0 + a * t positions[i] = positions[i-1] + velocities[i] * dt # r = r0 + v * t # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') # Mark the Earth's position plt.scatter(0, 0, color='blue', label='Earth', s=200) # Formatting plot plt.axhline(0, color='black',linewidth=0.5) plt.axvline(0, color='black',linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() This script demonstrates that: Implements gravitational equations of motion. Applies numerical integration to simulate the trajectory. Visualizes the computed trajectory. 4. Real-World Applications: Orbital Insertion: This is relevant for satellite deployments, where the payload needs to achieve a specific velocity for a stable orbit. Reentry: For returning objects to Earth, the payload must be decelerated to reenter the atmosphere safely. Escape: To leave Earth's gravitational influence (e.g., interplanetary missions), the payload must achieve escape velocity. 5. Conclusion Understanding the potential trajectories of a released payload is essential for space missions. By analyzing the velocity and Earth's gravitational influence, we can determine if an object will enter orbit, reenter Earth's atmosphere, or escape Earth's gravity.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-part","text":"","title":"1. Theoretical Part"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory): If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory): If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory): If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-method","text":"The following Python script calculates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6371000 # Radius of Earth (m) # Initial conditions (position, velocity) # Example: Launching at a height of 100 km above Earth's surface with horizontal velocity initial_position = np.array([R_earth + 100000, 0]) # [x, y] in meters (100 km above Earth) initial_velocity = np.array([0, 7500]) # Horizontal velocity in m/s # Time parameters dt = 1 # Time step (s) total_time = 5000 # Total time of simulation (s) num_steps = total_time // dt # Arrays to store position and velocity data positions = np.zeros((num_steps, 2)) velocities = np.zeros((num_steps, 2)) # Initial conditions positions[0] = initial_position velocities[0] = initial_velocity # Numerical integration (Euler's method) for i in range(1, num_steps): # Calculate the gravitational force r = np.linalg.norm(positions[i-1]) # Distance from Earth's center force = -G * M * positions[i-1] / r**3 # Gravitational force vector (N) # Update velocity and position velocities[i] = velocities[i-1] + force * dt # v = v0 + a * t positions[i] = positions[i-1] + velocities[i] * dt # r = r0 + v * t # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') # Mark the Earth's position plt.scatter(0, 0, color='blue', label='Earth', s=200) # Formatting plot plt.axhline(0, color='black',linewidth=0.5) plt.axvline(0, color='black',linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() This script demonstrates that: Implements gravitational equations of motion. Applies numerical integration to simulate the trajectory. Visualizes the computed trajectory.","title":"3. Numerical Method:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-real-world-applications","text":"Orbital Insertion: This is relevant for satellite deployments, where the payload needs to achieve a specific velocity for a stable orbit. Reentry: For returning objects to Earth, the payload must be decelerated to reenter the atmosphere safely. Escape: To leave Earth's gravitational influence (e.g., interplanetary missions), the payload must achieve escape velocity.","title":"4. Real-World Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"Understanding the potential trajectories of a released payload is essential for space missions. By analyzing the velocity and Earth's gravitational influence, we can determine if an object will enter orbit, reenter Earth's atmosphere, or escape Earth's gravity.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation 1.1 Kepler\u2019s Third Law Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, the relationship can be derived by combining Newton's law of gravitation with the concept of centripetal force. Newton's law of gravitation states that the gravitational force between two masses is proportional to the product of their masses and inversely proportional to the square of the distance between them. The centripetal force is the force that keeps an object moving in a circular path and is directed toward the center of the orbit. Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) . 1.2 Implications in Astronomy Calculating Planetary Mass: Using the period and radius of a planet's moon, we can calculate the mass of the planet. Estimating Orbital Radius: If the period of a planet's orbit around the Sun is known, we can estimate its orbital radius. Designing Satellite Orbits: This principle is used to create stable satellite orbits around Earth and other celestial bodies. 2. Real-World Examples The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets. 3. Computational Model The following Python script simulates verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Calculates the time taken for an object to complete an orbit at various distances. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship. 4. Extensions and Limitations Elliptical Orbits: Kepler\u2019s Third Law still holds, but instead of a fixed radius, the semi-major axis determines the orbital period. Relativistic Effects: In regions with intense gravity, such as near massive stars or black holes, general relativity introduces corrections to Kepler\u2019s laws. External Forces: Gravitational influences from other celestial bodies can cause deviations in orbits over long periods, leading to phenomena like precession and orbital resonance. 5. Conclusion Kepler\u2019s Third Law establishes a crucial connection between orbital period and radius, allowing precise calculations in celestial mechanics. This principle is essential in astronomy, satellite navigation, and space mission planning.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#11-keplers-third-law","text":"Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, the relationship can be derived by combining Newton's law of gravitation with the concept of centripetal force. Newton's law of gravitation states that the gravitational force between two masses is proportional to the product of their masses and inversely proportional to the square of the distance between them. The centripetal force is the force that keeps an object moving in a circular path and is directed toward the center of the orbit. Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) .","title":"1.1 Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#12-implications-in-astronomy","text":"Calculating Planetary Mass: Using the period and radius of a planet's moon, we can calculate the mass of the planet. Estimating Orbital Radius: If the period of a planet's orbit around the Sun is known, we can estimate its orbital radius. Designing Satellite Orbits: This principle is used to create stable satellite orbits around Earth and other celestial bodies.","title":"1.2 Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#2-real-world-examples","text":"The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets.","title":"2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#3-computational-model","text":"The following Python script simulates verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Calculates the time taken for an object to complete an orbit at various distances. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#4-extensions-and-limitations","text":"Elliptical Orbits: Kepler\u2019s Third Law still holds, but instead of a fixed radius, the semi-major axis determines the orbital period. Relativistic Effects: In regions with intense gravity, such as near massive stars or black holes, general relativity introduces corrections to Kepler\u2019s laws. External Forces: Gravitational influences from other celestial bodies can cause deviations in orbits over long periods, leading to phenomena like precession and orbital resonance.","title":"4. Extensions and Limitations"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler\u2019s Third Law establishes a crucial connection between orbital period and radius, allowing precise calculations in celestial mechanics. This principle is essential in astronomy, satellite navigation, and space mission planning.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Theoretical Foundation Definition of Cosmic Velocities Cosmic velocities define the minimum speeds needed for different space motions: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun. 2. Analysis of Results 2.1 Velocity Relationships Let's examine how these velocities vary with distance from a celestial body: # Create distance-velocity relationship plot plt.figure(figsize=(10, 6)) distances = np.linspace(1, 10, 1000) # In Earth radii earth_mass = 5.972e24 earth_radius = 6.371e6 v1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000 v2 = np.sqrt(2) * v1 plt.plot(distances, v1, label='First Cosmic Velocity') plt.plot(distances, v2, label='Second Cosmic Velocity') plt.xlabel('Distance (Earth Radii)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities vs Distance from Earth') plt.grid(True) plt.legend() plt.show() 2.2 Key Observations Inverse Square Relationship : Both first and second cosmic velocities decrease with the square root of distance. Mass Dependence : Larger celestial bodies require higher velocities for escape. Radius Effect : For a given mass, smaller bodies have higher surface escape velocities. 3. Python Script for Calculations and Visualization Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance to sun in meters) bodies = { \"Earth\": {\"mass\": 5.97e24, \"radius\": 6.37e6, \"distance_to_sun\": 1.496e11}, \"Mars\": {\"mass\": 6.42e23, \"radius\": 3.39e6, \"distance_to_sun\": 2.279e11}, \"Jupiter\": {\"mass\": 1.90e27, \"radius\": 6.99e7, \"distance_to_sun\": 7.785e11}, } # Function to calculate the first cosmic velocity (circular orbit) def first_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (escape from the star's gravitational influence) def third_velocity(mass, radius, distance_to_sun, second_velocity_earth): return np.sqrt(2 * G * mass / radius + (second_velocity_earth**2) / 2) # Dictionary to store the velocities for each body velocities = {} # Calculate the first and second cosmic velocities for each celestial body for body, data in bodies.items(): velocities[body] = { \"v1\": first_velocity(data[\"mass\"], data[\"radius\"]), \"v2\": second_velocity(data[\"mass\"], data[\"radius\"]), } # Calculate the third cosmic velocity for each celestial body for body, data in bodies.items(): second_velocity_earth = velocities[\"Earth\"][\"v2\"] if body == \"Earth\" else 0 velocities[body][\"v3\"] = third_velocity(data[\"mass\"], data[\"radius\"], data[\"distance_to_sun\"], second_velocity_earth) # Prepare data for plotting labels = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] v3_values = [velocities[body][\"v3\"] for body in labels] # Plotting the velocities x = np.arange(len(labels)) # X-axis positions for each body fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.2, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, 0.2, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + 0.2, v3_values, 0.2, label='Third Cosmic Velocity (v3)', color='red') # Adding labels and title ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() # Display the plot plt.tight_layout() plt.show() This script: Calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Visualizes a comparison of these velocities using a bar chart to illustrate the differences for each celestial body. 4. Importance in Space Exploration Escape Velocity: The escape velocity is essential for launching spacecraft and satellites. For instance, Earth\u2019s escape velocity is approximately 11.2 km/s, meaning a spacecraft needs this speed to break free from Earth's gravity without further propulsion. For interplanetary missions, the second cosmic velocity helps in launching spacecraft to other planets, such as Mars, where the escape velocity is much lower than Earth's. Orbital Velocity: The orbital velocity is critical for satellites. A satellite needs to achieve a specific orbital velocity to stay in a stable orbit around a planet, like Earth. This velocity ensures that the satellite's centrifugal force balances the gravitational pull from the planet. Solar Escape Velocity: The third cosmic velocity is particularly relevant for missions aimed at escaping not just a planet\u2019s gravity but the entire solar system, enabling spacecraft like Voyager 1 to leave the solar system and head into interstellar space. 5. Conclusion Understanding cosmic velocities is fundamental for space exploration, from launching satellites to planning interplanetary missions and even considering future interstellar travel. By calculating and visualizing these velocities for different celestial bodies, we can better understand the challenges of escaping gravitational forces and venturing into space.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#definition-of-cosmic-velocities","text":"Cosmic velocities define the minimum speeds needed for different space motions: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun.","title":"Definition of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#2-analysis-of-results","text":"","title":"2. Analysis of Results"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#21-velocity-relationships","text":"Let's examine how these velocities vary with distance from a celestial body: # Create distance-velocity relationship plot plt.figure(figsize=(10, 6)) distances = np.linspace(1, 10, 1000) # In Earth radii earth_mass = 5.972e24 earth_radius = 6.371e6 v1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000 v2 = np.sqrt(2) * v1 plt.plot(distances, v1, label='First Cosmic Velocity') plt.plot(distances, v2, label='Second Cosmic Velocity') plt.xlabel('Distance (Earth Radii)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities vs Distance from Earth') plt.grid(True) plt.legend() plt.show()","title":"2.1 Velocity Relationships"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#22-key-observations","text":"Inverse Square Relationship : Both first and second cosmic velocities decrease with the square root of distance. Mass Dependence : Larger celestial bodies require higher velocities for escape. Radius Effect : For a given mass, smaller bodies have higher surface escape velocities.","title":"2.2 Key Observations"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#3-python-script-for-calculations-and-visualization","text":"Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance to sun in meters) bodies = { \"Earth\": {\"mass\": 5.97e24, \"radius\": 6.37e6, \"distance_to_sun\": 1.496e11}, \"Mars\": {\"mass\": 6.42e23, \"radius\": 3.39e6, \"distance_to_sun\": 2.279e11}, \"Jupiter\": {\"mass\": 1.90e27, \"radius\": 6.99e7, \"distance_to_sun\": 7.785e11}, } # Function to calculate the first cosmic velocity (circular orbit) def first_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (escape from the star's gravitational influence) def third_velocity(mass, radius, distance_to_sun, second_velocity_earth): return np.sqrt(2 * G * mass / radius + (second_velocity_earth**2) / 2) # Dictionary to store the velocities for each body velocities = {} # Calculate the first and second cosmic velocities for each celestial body for body, data in bodies.items(): velocities[body] = { \"v1\": first_velocity(data[\"mass\"], data[\"radius\"]), \"v2\": second_velocity(data[\"mass\"], data[\"radius\"]), } # Calculate the third cosmic velocity for each celestial body for body, data in bodies.items(): second_velocity_earth = velocities[\"Earth\"][\"v2\"] if body == \"Earth\" else 0 velocities[body][\"v3\"] = third_velocity(data[\"mass\"], data[\"radius\"], data[\"distance_to_sun\"], second_velocity_earth) # Prepare data for plotting labels = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] v3_values = [velocities[body][\"v3\"] for body in labels] # Plotting the velocities x = np.arange(len(labels)) # X-axis positions for each body fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.2, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, 0.2, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + 0.2, v3_values, 0.2, label='Third Cosmic Velocity (v3)', color='red') # Adding labels and title ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() # Display the plot plt.tight_layout() plt.show() This script: Calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Visualizes a comparison of these velocities using a bar chart to illustrate the differences for each celestial body.","title":"3. Python Script for Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#4-importance-in-space-exploration","text":"Escape Velocity: The escape velocity is essential for launching spacecraft and satellites. For instance, Earth\u2019s escape velocity is approximately 11.2 km/s, meaning a spacecraft needs this speed to break free from Earth's gravity without further propulsion. For interplanetary missions, the second cosmic velocity helps in launching spacecraft to other planets, such as Mars, where the escape velocity is much lower than Earth's. Orbital Velocity: The orbital velocity is critical for satellites. A satellite needs to achieve a specific orbital velocity to stay in a stable orbit around a planet, like Earth. This velocity ensures that the satellite's centrifugal force balances the gravitational pull from the planet. Solar Escape Velocity: The third cosmic velocity is particularly relevant for missions aimed at escaping not just a planet\u2019s gravity but the entire solar system, enabling spacecraft like Voyager 1 to leave the solar system and head into interstellar space.","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_2/#5-conclusion","text":"Understanding cosmic velocities is fundamental for space exploration, from launching satellites to planning interplanetary missions and even considering future interstellar travel. By calculating and visualizing these velocities for different celestial bodies, we can better understand the challenges of escaping gravitational forces and venturing into space.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Theoretical Part Types of Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory): If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory): If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory): If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion. 2. Mathematical Analysis Equations of Motion The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations. 3. Numerical Method: The following Python script calculates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6371000 # Radius of Earth (m) # Initial conditions (position, velocity) # Example: Launching at a height of 100 km above Earth's surface with horizontal velocity initial_position = np.array([R_earth + 100000, 0]) # [x, y] in meters (100 km above Earth) initial_velocity = np.array([0, 7500]) # Horizontal velocity in m/s # Time parameters dt = 1 # Time step (s) total_time = 5000 # Total time of simulation (s) num_steps = total_time // dt # Arrays to store position and velocity data positions = np.zeros((num_steps, 2)) velocities = np.zeros((num_steps, 2)) # Initial conditions positions[0] = initial_position velocities[0] = initial_velocity # Numerical integration (Euler's method) for i in range(1, num_steps): # Calculate the gravitational force r = np.linalg.norm(positions[i-1]) # Distance from Earth's center force = -G * M * positions[i-1] / r**3 # Gravitational force vector (N) # Update velocity and position velocities[i] = velocities[i-1] + force * dt # v = v0 + a * t positions[i] = positions[i-1] + velocities[i] * dt # r = r0 + v * t # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') # Mark the Earth's position plt.scatter(0, 0, color='blue', label='Earth', s=200) # Formatting plot plt.axhline(0, color='black',linewidth=0.5) plt.axvline(0, color='black',linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() This script demonstrates that: Implements gravitational equations of motion. Applies numerical integration to simulate the trajectory. Visualizes the computed trajectory. 4. Real-World Applications: Orbital Insertion: This is relevant for satellite deployments, where the payload needs to achieve a specific velocity for a stable orbit. Reentry: For returning objects to Earth, the payload must be decelerated to reenter the atmosphere safely. Escape: To leave Earth's gravitational influence (e.g., interplanetary missions), the payload must achieve escape velocity. 5. Conclusion Understanding the potential trajectories of a released payload is essential for space missions. By analyzing the velocity and Earth's gravitational influence, we can determine if an object will enter orbit, reenter Earth's atmosphere, or escape Earth's gravity.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#1-theoretical-part","text":"","title":"1. Theoretical Part"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory): If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory): If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory): If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#3-numerical-method","text":"The following Python script calculates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6371000 # Radius of Earth (m) # Initial conditions (position, velocity) # Example: Launching at a height of 100 km above Earth's surface with horizontal velocity initial_position = np.array([R_earth + 100000, 0]) # [x, y] in meters (100 km above Earth) initial_velocity = np.array([0, 7500]) # Horizontal velocity in m/s # Time parameters dt = 1 # Time step (s) total_time = 5000 # Total time of simulation (s) num_steps = total_time // dt # Arrays to store position and velocity data positions = np.zeros((num_steps, 2)) velocities = np.zeros((num_steps, 2)) # Initial conditions positions[0] = initial_position velocities[0] = initial_velocity # Numerical integration (Euler's method) for i in range(1, num_steps): # Calculate the gravitational force r = np.linalg.norm(positions[i-1]) # Distance from Earth's center force = -G * M * positions[i-1] / r**3 # Gravitational force vector (N) # Update velocity and position velocities[i] = velocities[i-1] + force * dt # v = v0 + a * t positions[i] = positions[i-1] + velocities[i] * dt # r = r0 + v * t # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') # Mark the Earth's position plt.scatter(0, 0, color='blue', label='Earth', s=200) # Formatting plot plt.axhline(0, color='black',linewidth=0.5) plt.axvline(0, color='black',linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() This script demonstrates that: Implements gravitational equations of motion. Applies numerical integration to simulate the trajectory. Visualizes the computed trajectory.","title":"3. Numerical Method:"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#4-real-world-applications","text":"Orbital Insertion: This is relevant for satellite deployments, where the payload needs to achieve a specific velocity for a stable orbit. Reentry: For returning objects to Earth, the payload must be decelerated to reenter the atmosphere safely. Escape: To leave Earth's gravitational influence (e.g., interplanetary missions), the payload must achieve escape velocity.","title":"4. Real-World Applications:"},{"location":"1%20Physics/2%20Gravity/2%20Gravity/Problem_3/#5-conclusion","text":"Understanding the potential trajectories of a released payload is essential for space missions. By analyzing the velocity and Earth's gravitational influence, we can determine if an object will enter orbit, reenter Earth's atmosphere, or escape Earth's gravity.","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Theory Interference Patterns on a Water Surface Interference occurs when two or more waves meet and superpose. On a water surface, when waves emanate from different point sources, they overlap, creating an interference pattern. This is a fundamental concept in wave theory and can be observed in phenomena like water ripples. These interference patterns are crucial for understanding how waves combine, either reinforcing (constructive interference) or canceling out (destructive interference). 2. Problem Setup 2.1. Choosing a Regular Polygon We begin by selecting a regular polygon, such as an equilateral triangle, square, or pentagon. The wave sources are positioned at the vertices of the chosen polygon, ensuring they are equidistant from one another. 2.2. Computing the Superposition Each of the selected vertices acts as an individual wave source. The waves emitted from each source overlap and interfere with each other. The resulting interference pattern is obtained by summing the contributions from all sources, applying the principle of superposition to determine the final displacement at every point on the water surface. This process takes into account the distance from each point on the surface to each source and their corresponding phases. 3. Computational Model The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude of the wave lambda_ = 1.0 # Wavelength f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_ # Wave number phi_0 = 0 # Initial phase # Define the vertices of the regular polygon num_sources = 5 # Example: Regular pentagon radius = 5.0 # Distance from the center to the vertices # Function to compute the displacement at a given point def wave_displacement(x, y, source_x, source_y, A, k, omega, t, phi_0): r = np.sqrt((x - source_x)**2 + (y - source_y)**2) return A * np.sin(k * r - omega * t + phi_0) # Generate grid points for simulation x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x_vals, y_vals) # Time variable for animation or static plot t = 0 # You can vary this to see the change over time # Calculate the displacement due to all sources total_displacement = np.zeros_like(X) # Position of the sources at the vertices of the polygon angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources_x = radius * np.cos(angles) sources_y = radius * np.sin(angles) # Sum the wave displacements from all sources for i in range(num_sources): total_displacement += wave_displacement(X, Y, sources_x[i], sources_y[i], A, k, omega, t, phi_0) # Plot the interference pattern plt.figure(figsize=(8, 6)) cp = plt.contourf(X, Y, total_displacement, 20, cmap='RdBu_r') plt.colorbar(cp, label='Displacement') plt.title('Interference Pattern on Water Surface') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show() 4. Observations and Analysis The code simulates the interference pattern by calculating the displacement at each point on a 2D grid from the superposition of waves emitted from sources positioned at the vertices of a regular polygon. Wave Behavior : Each wave follows the form of a circular wave, and the displacement is computed at each grid point by considering the sum of the contributions from all sources. Superposition Principle : The resulting interference pattern is generated by summing the individual wave displacements. The constructive interference (where waves amplify) occurs where the displacements from the waves align, and destructive interference (where waves cancel out) occurs where the waves are out of phase. Number of Sources : By varying the number of sources (vertices of the polygon), different interference patterns are formed. For example, a pentagon creates a different pattern than a square or triangle due to the different geometric arrangements of the sources. Visualization : The contourf plot visually represents the displacement on the water surface, showing regions of constructive (bright) and destructive (dark) interference. 5. Conclusion By analyzing the interference patterns created by point sources arranged in a regular polygon, we can visualize how waves interact in a two-dimensional medium. The principle of superposition leads to the formation of complex interference patterns that are influenced by the number of sources and their positions. These patterns are essential for understanding wave behavior, and the same principles can be applied to more advanced wave phenomena in fields such as acoustics, optics, and electromagnetic waves.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a Water Surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theory","text":"","title":"1. Theory"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"Interference occurs when two or more waves meet and superpose. On a water surface, when waves emanate from different point sources, they overlap, creating an interference pattern. This is a fundamental concept in wave theory and can be observed in phenomena like water ripples. These interference patterns are crucial for understanding how waves combine, either reinforcing (constructive interference) or canceling out (destructive interference).","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-problem-setup","text":"","title":"2. Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-choosing-a-regular-polygon","text":"We begin by selecting a regular polygon, such as an equilateral triangle, square, or pentagon. The wave sources are positioned at the vertices of the chosen polygon, ensuring they are equidistant from one another.","title":"2.1. Choosing a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-computing-the-superposition","text":"Each of the selected vertices acts as an individual wave source. The waves emitted from each source overlap and interfere with each other. The resulting interference pattern is obtained by summing the contributions from all sources, applying the principle of superposition to determine the final displacement at every point on the water surface. This process takes into account the distance from each point on the surface to each source and their corresponding phases.","title":"2.2. Computing the Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-model","text":"The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude of the wave lambda_ = 1.0 # Wavelength f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_ # Wave number phi_0 = 0 # Initial phase # Define the vertices of the regular polygon num_sources = 5 # Example: Regular pentagon radius = 5.0 # Distance from the center to the vertices # Function to compute the displacement at a given point def wave_displacement(x, y, source_x, source_y, A, k, omega, t, phi_0): r = np.sqrt((x - source_x)**2 + (y - source_y)**2) return A * np.sin(k * r - omega * t + phi_0) # Generate grid points for simulation x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x_vals, y_vals) # Time variable for animation or static plot t = 0 # You can vary this to see the change over time # Calculate the displacement due to all sources total_displacement = np.zeros_like(X) # Position of the sources at the vertices of the polygon angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources_x = radius * np.cos(angles) sources_y = radius * np.sin(angles) # Sum the wave displacements from all sources for i in range(num_sources): total_displacement += wave_displacement(X, Y, sources_x[i], sources_y[i], A, k, omega, t, phi_0) # Plot the interference pattern plt.figure(figsize=(8, 6)) cp = plt.contourf(X, Y, total_displacement, 20, cmap='RdBu_r') plt.colorbar(cp, label='Displacement') plt.title('Interference Pattern on Water Surface') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show()","title":"3. Computational Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"The code simulates the interference pattern by calculating the displacement at each point on a 2D grid from the superposition of waves emitted from sources positioned at the vertices of a regular polygon. Wave Behavior : Each wave follows the form of a circular wave, and the displacement is computed at each grid point by considering the sum of the contributions from all sources. Superposition Principle : The resulting interference pattern is generated by summing the individual wave displacements. The constructive interference (where waves amplify) occurs where the displacements from the waves align, and destructive interference (where waves cancel out) occurs where the waves are out of phase. Number of Sources : By varying the number of sources (vertices of the polygon), different interference patterns are formed. For example, a pentagon creates a different pattern than a square or triangle due to the different geometric arrangements of the sources. Visualization : The contourf plot visually represents the displacement on the water surface, showing regions of constructive (bright) and destructive (dark) interference.","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"By analyzing the interference patterns created by point sources arranged in a regular polygon, we can visualize how waves interact in a two-dimensional medium. The principle of superposition leads to the formation of complex interference patterns that are influenced by the number of sources and their positions. These patterns are essential for understanding wave behavior, and the same principles can be applied to more advanced wave phenomena in fields such as acoustics, optics, and electromagnetic waves.","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Investigating Charged Particle Motion under Electromagnetic Fields 1. Theoretical Foundation Governing Equations The motion of charged particles in electromagnetic fields is governed by the Lorentz force: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Newton's second law: \\[ m\\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] In component form for 3D motion: \\[ m\\frac{dv_x}{dt} = qE_x + q(v_yB_z - v_zB_y) $$ $$ m\\frac{dv_y}{dt} = qE_y + q(v_zB_x - v_xB_z) $$ $$ m\\frac{dv_z}{dt} = qE_z + q(v_xB_y - v_yB_x) \\] Key Parameters Cyclotron Frequency: $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius: $$ r_L = \\frac{mv_\\perp}{qB} $$ E\u00d7B Drift Velocity: $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Let's simulate these motions using Python: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import odeint def lorentz_force(state, t, q, m, E, B): x, y, z, vx, vy, vz = state # Force components dvx_dt = (q/m) * (E[0] + vy*B[2] - vz*B[1]) dvy_dt = (q/m) * (E[1] + vz*B[0] - vx*B[2]) dvz_dt = (q/m) * (E[2] + vx*B[1] - vy*B[0]) return [vx, vy, vz, dvx_dt, dvy_dt, dvz_dt] # Parameters q = 1.6e-19 # electron charge m = 9.1e-31 # electron mass t = np.linspace(0, 1e-9, 1000) # Case 1: Uniform Magnetic Field B = [0, 0, 1.0] # Tesla E = [0, 0, 0] # V/m initial_state = [0, 0, 0, 1e6, 1e6, 0] # Initial position and velocity solution = odeint(lorentz_force, initial_state, t, args=(q, m, E, B)) # Plot trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(solution[:, 0], solution[:, 1], solution[:, 2]) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Particle Motion in Uniform Magnetic Field') plt.show() Analysis of Different Field Configurations Let's examine the E\u00d7B drift: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def lorentz_force(state, t, q, m, E, B): \"\"\" Calculates the Lorentz force and returns the derivatives of the state variables. Args: state: [x, y, z, vx, vy, vz] (position and velocity) t: Time (not used in this autonomous equation, but required by odeint) q: Charge of the particle m: Mass of the particle E: Electric field vector [Ex, Ey, Ez] B: Magnetic field vector [Bx, By, Bz] Returns: [dx/dt, dy/dt, dz/dt, dvx/dt, dvy/dt, dvz/dt] \"\"\" x, y, z, vx, vy, vz = state # Calculate the electric force Fx = q * E[0] Fy = q * E[1] Fz = q * E[2] # Calculate the magnetic force (cross product) Fx += q * (vy * B[2] - vz * B[1]) Fy += q * (vz * B[0] - vx * B[2]) Fz += q * (vx * B[1] - vy * B[0]) # Calculate the derivatives dxdt = vx dydt = vy dzdt = vz dvxdt = Fx / m dvydt = Fy / m dvzdt = Fz / m return dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt # Case 2: Crossed E and B fields E = [1e5, 0, 0] # V/m B = [0, 0, 1.0] # Tesla initial_state = [0, 0, 0, 0, 1e6, 0] # x, y, z, vx, vy, vz q = 1.6e-19 # Charge of a proton (Coulombs) m = 1.67e-27 # Mass of a proton (kg) t = np.linspace(0, 1e-6, 500) # Time vector from 0 to 1 microsecond, 500 points solution_ExB = odeint(lorentz_force, initial_state, t, args=(q, m, E, B)) # Plot E\u00d7B drift plt.figure(figsize=(12, 5)) plt.subplot(121) plt.plot(solution_ExB[:, 0], solution_ExB[:, 1]) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('E\u00d7B Drift Trajectory') plt.grid(True) # Plot velocity components plt.subplot(122) plt.plot(t, solution_ExB[:, 3], label='vx') plt.plot(t, solution_ExB[:, 4], label='vy') plt.xlabel('Time (s)') plt.ylabel('Velocity (m/s)') plt.title('Velocity Components') plt.legend() plt.grid(True) plt.tight_layout() plt.show() 2. Parameter Study Let's investigate how the Larmor radius changes with magnetic field strength: import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of the particle (C) m = 9.1e-31 # Mass of the particle (kg) v_perp = 1e6 # Perpendicular velocity (m/s) # Larmor radius function def larmor_radius(v_perp, B, q, m): return m * v_perp / (q * B) # Range of magnetic field values (T) B_values = np.linspace(0.1, 2.0, 200) # Compute radii radii = larmor_radius(v_perp, B_values, q, m) # Plotting plt.figure(figsize=(10, 6)) plt.plot(B_values, radii, color='blue') plt.xlabel('Magnetic Field Strength (T)') plt.ylabel('Larmor Radius (m)') plt.title('Larmor Radius vs Magnetic Field Strength') plt.grid(True) plt.tight_layout() plt.show() 3. Applications Cyclotron Operation The cyclotron frequency determines particle acceleration: import numpy as np import matplotlib.pyplot as plt def cyclotron_freq(B, q, m): \"\"\"Calculates the cyclotron frequency. Args: B: Magnetic field strength (T) q: Charge of the particle (C) m: Mass of the particle (kg) Returns: Cyclotron frequency (Hz) \"\"\" return q * B / m # Constants q = 1.6e-19 # Charge of a proton (C) m = 1.67e-27 # Mass of a proton (kg) # Generate magnetic field values B_range = np.linspace(0.1, 3.0, 100) # Tesla # Calculate cyclotron frequencies frequencies = [cyclotron_freq(B, q, m) for B in B_range] # Plotting plt.figure(figsize=(10, 6)) plt.plot(B_range, np.array(frequencies) / 1e9) # Convert to GHz plt.xlabel('Magnetic Field (T)') plt.ylabel('Cyclotron Frequency (GHz)') plt.title('Cyclotron Frequency vs Magnetic Field') plt.grid(True) plt.show() # Create table data for display table_data = {'Magnetic Field (T)': B_range, 'Cyclotron Frequency (GHz)': np.array(frequencies) / 1e9} # Print the table print(\"Magnetic Field (T) | Cyclotron Frequency (GHz)\") print(\"-------------------|---------------------------\") for B, f in zip(B_range, frequencies): print(f\"{B:.2f} | {f / 1e9:.2f}\") # formatted output 4. Advanced Analysis: Non-uniform Fields Uniform Magnetic Field: The particle moves in a circle (if the initial velocity is perpendicular to the field) or a helix (if the initial velocity has a component parallel to the field). The radius of the circle (Larmor radius) is given by r=mv/(qB) . This motion is fundamental to cyclotrons, where particles are accelerated in a spiral path by a combination of magnetic and electric fields. Combined Uniform Electric and Magnetic Fields: The particle exhibits helical motion with a drift velocity in the direction perpendicular to both the electric and magnetic fields. This E\u00d7B drift is important in plasma physics and is used in devices like magnetrons. 5. Practical Applications Particle Accelerators Cyclotrons Synchrotrons Linear accelerators Plasma Confinement Tokamaks Magnetic mirrors Stellarators Scientific Instruments Mass spectrometers Electron microscopes Beta-ray spectrometers Conclusion The Lorentz force is a fundamental mechanism for controlling charged particle motion. Our simulations illustrate how various field configurations are applied in modern physics and technology, demonstrating the versatility of electric and magnetic fields in particle manipulation and confinement. Future Extensions Include effects of relativity for high-speed particles Add particle collisions and interaction effects Simulate more detailed field geometries Include quantum effects at very low energy levels","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-theoretical-foundation","text":"Governing Equations The motion of charged particles in electromagnetic fields is governed by the Lorentz force: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Newton's second law: \\[ m\\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] In component form for 3D motion: \\[ m\\frac{dv_x}{dt} = qE_x + q(v_yB_z - v_zB_y) $$ $$ m\\frac{dv_y}{dt} = qE_y + q(v_zB_x - v_xB_z) $$ $$ m\\frac{dv_z}{dt} = qE_z + q(v_xB_y - v_yB_x) \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-parameters","text":"Cyclotron Frequency: $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius: $$ r_L = \\frac{mv_\\perp}{qB} $$ E\u00d7B Drift Velocity: $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Let's simulate these motions using Python: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import odeint def lorentz_force(state, t, q, m, E, B): x, y, z, vx, vy, vz = state # Force components dvx_dt = (q/m) * (E[0] + vy*B[2] - vz*B[1]) dvy_dt = (q/m) * (E[1] + vz*B[0] - vx*B[2]) dvz_dt = (q/m) * (E[2] + vx*B[1] - vy*B[0]) return [vx, vy, vz, dvx_dt, dvy_dt, dvz_dt] # Parameters q = 1.6e-19 # electron charge m = 9.1e-31 # electron mass t = np.linspace(0, 1e-9, 1000) # Case 1: Uniform Magnetic Field B = [0, 0, 1.0] # Tesla E = [0, 0, 0] # V/m initial_state = [0, 0, 0, 1e6, 1e6, 0] # Initial position and velocity solution = odeint(lorentz_force, initial_state, t, args=(q, m, E, B)) # Plot trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(solution[:, 0], solution[:, 1], solution[:, 2]) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Particle Motion in Uniform Magnetic Field') plt.show()","title":"Key Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analysis-of-different-field-configurations","text":"Let's examine the E\u00d7B drift: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def lorentz_force(state, t, q, m, E, B): \"\"\" Calculates the Lorentz force and returns the derivatives of the state variables. Args: state: [x, y, z, vx, vy, vz] (position and velocity) t: Time (not used in this autonomous equation, but required by odeint) q: Charge of the particle m: Mass of the particle E: Electric field vector [Ex, Ey, Ez] B: Magnetic field vector [Bx, By, Bz] Returns: [dx/dt, dy/dt, dz/dt, dvx/dt, dvy/dt, dvz/dt] \"\"\" x, y, z, vx, vy, vz = state # Calculate the electric force Fx = q * E[0] Fy = q * E[1] Fz = q * E[2] # Calculate the magnetic force (cross product) Fx += q * (vy * B[2] - vz * B[1]) Fy += q * (vz * B[0] - vx * B[2]) Fz += q * (vx * B[1] - vy * B[0]) # Calculate the derivatives dxdt = vx dydt = vy dzdt = vz dvxdt = Fx / m dvydt = Fy / m dvzdt = Fz / m return dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt # Case 2: Crossed E and B fields E = [1e5, 0, 0] # V/m B = [0, 0, 1.0] # Tesla initial_state = [0, 0, 0, 0, 1e6, 0] # x, y, z, vx, vy, vz q = 1.6e-19 # Charge of a proton (Coulombs) m = 1.67e-27 # Mass of a proton (kg) t = np.linspace(0, 1e-6, 500) # Time vector from 0 to 1 microsecond, 500 points solution_ExB = odeint(lorentz_force, initial_state, t, args=(q, m, E, B)) # Plot E\u00d7B drift plt.figure(figsize=(12, 5)) plt.subplot(121) plt.plot(solution_ExB[:, 0], solution_ExB[:, 1]) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('E\u00d7B Drift Trajectory') plt.grid(True) # Plot velocity components plt.subplot(122) plt.plot(t, solution_ExB[:, 3], label='vx') plt.plot(t, solution_ExB[:, 4], label='vy') plt.xlabel('Time (s)') plt.ylabel('Velocity (m/s)') plt.title('Velocity Components') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Analysis of Different Field Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-parameter-study","text":"Let's investigate how the Larmor radius changes with magnetic field strength: import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of the particle (C) m = 9.1e-31 # Mass of the particle (kg) v_perp = 1e6 # Perpendicular velocity (m/s) # Larmor radius function def larmor_radius(v_perp, B, q, m): return m * v_perp / (q * B) # Range of magnetic field values (T) B_values = np.linspace(0.1, 2.0, 200) # Compute radii radii = larmor_radius(v_perp, B_values, q, m) # Plotting plt.figure(figsize=(10, 6)) plt.plot(B_values, radii, color='blue') plt.xlabel('Magnetic Field Strength (T)') plt.ylabel('Larmor Radius (m)') plt.title('Larmor Radius vs Magnetic Field Strength') plt.grid(True) plt.tight_layout() plt.show()","title":"2. Parameter Study"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-applications","text":"","title":"3. Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-operation","text":"The cyclotron frequency determines particle acceleration: import numpy as np import matplotlib.pyplot as plt def cyclotron_freq(B, q, m): \"\"\"Calculates the cyclotron frequency. Args: B: Magnetic field strength (T) q: Charge of the particle (C) m: Mass of the particle (kg) Returns: Cyclotron frequency (Hz) \"\"\" return q * B / m # Constants q = 1.6e-19 # Charge of a proton (C) m = 1.67e-27 # Mass of a proton (kg) # Generate magnetic field values B_range = np.linspace(0.1, 3.0, 100) # Tesla # Calculate cyclotron frequencies frequencies = [cyclotron_freq(B, q, m) for B in B_range] # Plotting plt.figure(figsize=(10, 6)) plt.plot(B_range, np.array(frequencies) / 1e9) # Convert to GHz plt.xlabel('Magnetic Field (T)') plt.ylabel('Cyclotron Frequency (GHz)') plt.title('Cyclotron Frequency vs Magnetic Field') plt.grid(True) plt.show() # Create table data for display table_data = {'Magnetic Field (T)': B_range, 'Cyclotron Frequency (GHz)': np.array(frequencies) / 1e9} # Print the table print(\"Magnetic Field (T) | Cyclotron Frequency (GHz)\") print(\"-------------------|---------------------------\") for B, f in zip(B_range, frequencies): print(f\"{B:.2f} | {f / 1e9:.2f}\") # formatted output","title":"Cyclotron Operation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-advanced-analysis-non-uniform-fields","text":"Uniform Magnetic Field: The particle moves in a circle (if the initial velocity is perpendicular to the field) or a helix (if the initial velocity has a component parallel to the field). The radius of the circle (Larmor radius) is given by r=mv/(qB) . This motion is fundamental to cyclotrons, where particles are accelerated in a spiral path by a combination of magnetic and electric fields. Combined Uniform Electric and Magnetic Fields: The particle exhibits helical motion with a drift velocity in the direction perpendicular to both the electric and magnetic fields. This E\u00d7B drift is important in plasma physics and is used in devices like magnetrons.","title":"4. Advanced Analysis: Non-uniform Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-practical-applications","text":"","title":"5. Practical Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"Cyclotrons Synchrotrons Linear accelerators","title":"Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","text":"Tokamaks Magnetic mirrors Stellarators","title":"Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scientific-instruments","text":"Mass spectrometers Electron microscopes Beta-ray spectrometers","title":"Scientific Instruments"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"The Lorentz force is a fundamental mechanism for controlling charged particle motion. Our simulations illustrate how various field configurations are applied in modern physics and technology, demonstrating the versatility of electric and magnetic fields in particle manipulation and confinement.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#future-extensions","text":"Include effects of relativity for high-speed particles Add particle collisions and interaction effects Simulate more detailed field geometries Include quantum effects at very low energy levels","title":"Future Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Theoretical Foundation 1.1 Basic Circuit Laws For resistors in series and parallel, the equivalent resistance is given by: Series: $$ R_{eq} = \\sum_{i=1}^n R_i $$ Parallel: $$ \\frac{1}{R_{eq}} = \\sum_{i=1}^n \\frac{1}{R_i} $$ 1.2 Graph Representation A circuit can be represented as a weighted undirected graph G(V,E) where: - V: vertices (nodes) represent junctions - E: edges represent resistors - Weights: resistance values import numpy as np import matplotlib.pyplot as plt import networkx as nx def create_example_circuit(): G = nx.Graph() # Add edges with resistance values edges = [(0,1,2), (1,2,4), (2,3,1), (0,2,3), (1,3,5)] G.add_weighted_edges_from(edges) return G def plot_circuit(G, title=\"Circuit Graph\"): plt.figure(figsize=(10, 8)) pos = nx.spring_layout(G) # Draw edges with weights nx.draw_networkx_edges(G, pos, width=2) nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) # Add edge labels (resistance values) edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels) plt.title(title) plt.axis('off') plt.show() # Create and plot example circuit G = create_example_circuit() plot_circuit(G) 2. Algorithm Implementation 2.1 Series Reduction For series reduction, we identify nodes with exactly two connections: def find_series_nodes(G): return [node for node in G.nodes() if G.degree(node) == 2] def reduce_series(G, node): neighbors = list(G.neighbors(node)) r1 = G[node][neighbors[0]]['weight'] r2 = G[node][neighbors[1]]['weight'] # Add new combined resistance G.add_edge(neighbors[0], neighbors[1], weight=r1 + r2) G.remove_node(node) return G # Demonstrate series reduction G_series = create_example_circuit() plot_circuit(G_series, \"Before Series Reduction\") node = find_series_nodes(G_series)[0] G_series = reduce_series(G_series, node) plot_circuit(G_series, \"After Series Reduction\") 2.2 Parallel Reduction For parallel resistors between the same nodes: def reduce_parallel(G): for u in G.nodes(): for v in G.nodes(): if u < v and G.has_edge(u, v): # Find parallel edges paths = list(nx.edge_disjoint_paths(G, u, v)) if len(paths) > 1: # Calculate equivalent resistance r_eq = 0 for path in paths: r_path = sum(1/G[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)) r_eq += r_path r_eq = 1/r_eq # Remove old edges and add new equivalent for path in paths: for i in range(len(path)-1): G.remove_edge(path[i], path[i+1]) G.add_edge(u, v, weight=r_eq) return G # Demonstrate parallel reduction G_parallel = nx.Graph() G_parallel.add_weighted_edges_from([(0,1,2), (0,1,3)]) plot_circuit(G_parallel, \"Before Parallel Reduction\") G_parallel = reduce_parallel(G_parallel) plot_circuit(G_parallel, \"After Parallel Reduction\") 3. Complete Algorithm def calculate_equivalent_resistance(G): while len(G.nodes()) > 2: # Try series reduction first series_nodes = find_series_nodes(G) if series_nodes: G = reduce_series(G, series_nodes[0]) continue # Then try parallel reduction G_before = G.copy() G = reduce_parallel(G) if nx.is_isomorphic(G, G_before): break if len(G.nodes()) == 2: nodes = list(G.nodes()) return G[nodes[0]][nodes[1]]['weight'] return None # Test with example circuits def test_circuit(edges, title=\"Test Circuit\"): G = nx.Graph() G.add_weighted_edges_from(edges) plot_circuit(G, f\"{title} - Initial\") R_eq = calculate_equivalent_resistance(G) print(f\"Equivalent Resistance: {R_eq:.2f} \u03a9\") plot_circuit(G, f\"{title} - Final\") return R_eq # Example 1: Simple series-parallel test_circuit([(0,1,2), (1,2,3), (0,2,6)], \"Series-Parallel Circuit\") Equivalent Resistance = 8.00 \u03a9 4. Analysis and Complexity 4.1 Time Complexity Series reduction: O(V) for finding nodes, O(1) for reduction Parallel reduction: O(V\u00b2) for checking all node pairs Overall: O(V\u00b3) in worst case 4.2 Space Complexity O(V + E) for graph storage O(V) additional space for algorithm operations 5. Applications and Extensions The graph-based circuit analysis approach has several key applications and potential extensions: 5.1 Circuit Analysis Software The graph-based method can be used in: Automated circuit simplification tools. Resistance calculation modules. Real-time analysis systems. Component parameter optimization software. 5.2 Network Optimization The approach is adaptable for: Power grid analysis and modeling. Circuit design optimization. Load balancing calculations. Network reliability assessments. 5.3 Educational Tools The method is ideal for: Interactive circuit visualization. Step-by-step reduction demonstrations. Virtual circuit-building exercises. Progress tracking for learning systems. This graph theory-based method provides a strong foundation for these applications, offering both mathematical rigor and computational efficiency. 6. Conclusions The graph theory-based approach offers: A structured method for circuit analysis. Clear visualization of the reduction steps. An extensible framework for handling complex circuits. Future improvements could involve: Calculations for voltage and current. Support for active components. Optimizations for specific types of circuits.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"Equivalent Resistance Using Graph Theory","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-basic-circuit-laws","text":"For resistors in series and parallel, the equivalent resistance is given by: Series: $$ R_{eq} = \\sum_{i=1}^n R_i $$ Parallel: $$ \\frac{1}{R_{eq}} = \\sum_{i=1}^n \\frac{1}{R_i} $$","title":"1.1 Basic Circuit Laws"},{"location":"1%20Physics/5%20Circuits/Problem_1/#12-graph-representation","text":"A circuit can be represented as a weighted undirected graph G(V,E) where: - V: vertices (nodes) represent junctions - E: edges represent resistors - Weights: resistance values import numpy as np import matplotlib.pyplot as plt import networkx as nx def create_example_circuit(): G = nx.Graph() # Add edges with resistance values edges = [(0,1,2), (1,2,4), (2,3,1), (0,2,3), (1,3,5)] G.add_weighted_edges_from(edges) return G def plot_circuit(G, title=\"Circuit Graph\"): plt.figure(figsize=(10, 8)) pos = nx.spring_layout(G) # Draw edges with weights nx.draw_networkx_edges(G, pos, width=2) nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) # Add edge labels (resistance values) edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels) plt.title(title) plt.axis('off') plt.show() # Create and plot example circuit G = create_example_circuit() plot_circuit(G)","title":"1.2 Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-implementation","text":"","title":"2. Algorithm Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-series-reduction","text":"For series reduction, we identify nodes with exactly two connections: def find_series_nodes(G): return [node for node in G.nodes() if G.degree(node) == 2] def reduce_series(G, node): neighbors = list(G.neighbors(node)) r1 = G[node][neighbors[0]]['weight'] r2 = G[node][neighbors[1]]['weight'] # Add new combined resistance G.add_edge(neighbors[0], neighbors[1], weight=r1 + r2) G.remove_node(node) return G # Demonstrate series reduction G_series = create_example_circuit() plot_circuit(G_series, \"Before Series Reduction\") node = find_series_nodes(G_series)[0] G_series = reduce_series(G_series, node) plot_circuit(G_series, \"After Series Reduction\")","title":"2.1 Series Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-parallel-reduction","text":"For parallel resistors between the same nodes: def reduce_parallel(G): for u in G.nodes(): for v in G.nodes(): if u < v and G.has_edge(u, v): # Find parallel edges paths = list(nx.edge_disjoint_paths(G, u, v)) if len(paths) > 1: # Calculate equivalent resistance r_eq = 0 for path in paths: r_path = sum(1/G[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)) r_eq += r_path r_eq = 1/r_eq # Remove old edges and add new equivalent for path in paths: for i in range(len(path)-1): G.remove_edge(path[i], path[i+1]) G.add_edge(u, v, weight=r_eq) return G # Demonstrate parallel reduction G_parallel = nx.Graph() G_parallel.add_weighted_edges_from([(0,1,2), (0,1,3)]) plot_circuit(G_parallel, \"Before Parallel Reduction\") G_parallel = reduce_parallel(G_parallel) plot_circuit(G_parallel, \"After Parallel Reduction\")","title":"2.2 Parallel Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-complete-algorithm","text":"def calculate_equivalent_resistance(G): while len(G.nodes()) > 2: # Try series reduction first series_nodes = find_series_nodes(G) if series_nodes: G = reduce_series(G, series_nodes[0]) continue # Then try parallel reduction G_before = G.copy() G = reduce_parallel(G) if nx.is_isomorphic(G, G_before): break if len(G.nodes()) == 2: nodes = list(G.nodes()) return G[nodes[0]][nodes[1]]['weight'] return None # Test with example circuits def test_circuit(edges, title=\"Test Circuit\"): G = nx.Graph() G.add_weighted_edges_from(edges) plot_circuit(G, f\"{title} - Initial\") R_eq = calculate_equivalent_resistance(G) print(f\"Equivalent Resistance: {R_eq:.2f} \u03a9\") plot_circuit(G, f\"{title} - Final\") return R_eq # Example 1: Simple series-parallel test_circuit([(0,1,2), (1,2,3), (0,2,6)], \"Series-Parallel Circuit\") Equivalent Resistance = 8.00 \u03a9","title":"3. Complete Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-analysis-and-complexity","text":"","title":"4. Analysis and Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#41-time-complexity","text":"Series reduction: O(V) for finding nodes, O(1) for reduction Parallel reduction: O(V\u00b2) for checking all node pairs Overall: O(V\u00b3) in worst case","title":"4.1 Time Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#42-space-complexity","text":"O(V + E) for graph storage O(V) additional space for algorithm operations","title":"4.2 Space Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-applications-and-extensions","text":"The graph-based circuit analysis approach has several key applications and potential extensions:","title":"5. Applications and Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/#51-circuit-analysis-software","text":"The graph-based method can be used in: Automated circuit simplification tools. Resistance calculation modules. Real-time analysis systems. Component parameter optimization software.","title":"5.1 Circuit Analysis Software"},{"location":"1%20Physics/5%20Circuits/Problem_1/#52-network-optimization","text":"The approach is adaptable for: Power grid analysis and modeling. Circuit design optimization. Load balancing calculations. Network reliability assessments.","title":"5.2 Network Optimization"},{"location":"1%20Physics/5%20Circuits/Problem_1/#53-educational-tools","text":"The method is ideal for: Interactive circuit visualization. Step-by-step reduction demonstrations. Virtual circuit-building exercises. Progress tracking for learning systems. This graph theory-based method provides a strong foundation for these applications, offering both mathematical rigor and computational efficiency.","title":"5.3 Educational Tools"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-conclusions","text":"The graph theory-based approach offers: A structured method for circuit analysis. Clear visualization of the reduction steps. An extensible framework for handling complex circuits. Future improvements could involve: Calculations for voltage and current. Support for active components. Optimizations for specific types of circuits.","title":"6. Conclusions"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations 1.1 Theoretical Part The Central Limit Theorem (CLT) asserts that the distribution of sample means approximates a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Through simulation, we can visualize and understand this convergence. 1.2 Mathematical Expression For a population with mean \u03bc and variance \u03c3\u00b2, if we take samples of size n: \\[ \\bar{X}_n \\sim N(\\mu, \\frac{\\sigma^2}{n}) \\] where \\(\\bar{X}_n\\) is the sample mean distribution. The standardized form of the sampling distribution follows: \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\sim N(0,1) \\] 2. Implementation and Analysis We\u2019ll examine three population distributions: Uniform Distribution Exponential Distribution Binomial Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() return fig # 1. Uniform Distribution uniform_pop = np.random.uniform(0, 10, 10000) fig1 = plot_sampling_distribution(uniform_pop, [5, 10, 30, 50], title=\"Uniform Distribution (0, 10)\") plt.show() 2.1 Uniform Distribution Analysis The uniform distribution has a theoretical mean of: $$ \\mu = \\frac{a + b}{2} $$ and variance: $$ \\sigma^2 = \\frac{(b-a)^2}{12} $$ For our case (0,10): - \u03bc = 5 - \u03c3\u00b2 \u2248 8.33 # 2. Exponential Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() return fig exponential_pop = np.random.exponential(2, 10000) fig2 = plot_sampling_distribution(exponential_pop, [5, 10, 30, 50], title=\"Exponential Distribution (\u03bb=0.5)\") plt.show() 2.2 Exponential Distribution Analysis For exponential distribution with rate parameter \u03bb: $$ \\mu = \\frac{1}{\\lambda} $$ $$ \\sigma^2 = \\frac{1}{\\lambda^2} $$ # 3. Binomial Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() # This line and the one below were incorrectly indented. return fig # Indentation fixed to align with the function block. binomial_pop = np.random.binomial(20, 0.3, 10000) fig3 = plot_sampling_distribution(binomial_pop, [5, 10, 30, 50], title=\"Binomial Distribution (n=20, p=0.3)\") plt.show() 2.3 Binomial Distribution Analysis For binomial distribution: $$ \\mu = np $$ $$ \\sigma^2 = np(1-p) $$ 3. Convergence Analysis Let's analyze the rate of convergence using Q-Q plots: def plot_qq_analysis(population, sample_sizes, n_samples=1000): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle('Q-Q Plots for Different Sample Sizes', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] stats.probplot(sample_means, dist=\"norm\", plot=axes[row, col]) axes[row, col].set_title(f'Sample Size = {n}') plt.tight_layout() return fig # Analyze convergence for exponential distribution fig4 = plot_qq_analysis(exponential_pop, [5, 10, 30, 50]) plt.show() 4. Standard Error Analysis As predicted by the CLT, the standard error should reduce in proportion to the inverse square root of the sample size. \\[ SE = \\frac{\\sigma}{\\sqrt{n}} \\] def plot_standard_error(population, max_sample_size=100): sample_sizes = np.arange(5, max_sample_size + 1, 5) theoretical_se = np.std(population) / np.sqrt(sample_sizes) empirical_se = [] for n in sample_sizes: sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(1000)] empirical_se.append(np.std(sample_means)) plt.figure(figsize=(10, 6)) plt.plot(sample_sizes, theoretical_se, 'r-', label='Theoretical SE') plt.plot(sample_sizes, empirical_se, 'b--', label='Empirical SE') plt.xlabel('Sample Size') plt.ylabel('Standard Error') plt.title('Standard Error vs Sample Size') plt.legend() plt.grid(True) return plt.gcf() fig5 = plot_standard_error(exponential_pop) plt.show() 5. Real-World Applications of CLT Manufacturing and Quality Control Determining whether product measurements fall within acceptable tolerance levels. Finance and Economics Estimating returns and risk based on historical sampling from market data. Scientific Research Building confidence intervals and conducting hypothesis tests when sample data is used. 6. Conclusions The simulations provide strong evidence supporting the Central Limit Theorem: Sampling distributions increasingly resemble the normal distribution as sample size grows. The original shape of the population affects how rapidly this normality is approached. The standard error diminishes predictably with larger samples. These properties hold regardless of whether the population is symmetric, skewed, or discrete.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"Exploring the Central Limit Theorem through Simulations","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#11-theoretical-part","text":"The Central Limit Theorem (CLT) asserts that the distribution of sample means approximates a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Through simulation, we can visualize and understand this convergence.","title":"1.1 Theoretical Part"},{"location":"1%20Physics/6%20Statistics/Problem_1/#12-mathematical-expression","text":"For a population with mean \u03bc and variance \u03c3\u00b2, if we take samples of size n: \\[ \\bar{X}_n \\sim N(\\mu, \\frac{\\sigma^2}{n}) \\] where \\(\\bar{X}_n\\) is the sample mean distribution. The standardized form of the sampling distribution follows: \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\sim N(0,1) \\]","title":"1.2 Mathematical Expression"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-implementation-and-analysis","text":"We\u2019ll examine three population distributions: Uniform Distribution Exponential Distribution Binomial Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() return fig # 1. Uniform Distribution uniform_pop = np.random.uniform(0, 10, 10000) fig1 = plot_sampling_distribution(uniform_pop, [5, 10, 30, 50], title=\"Uniform Distribution (0, 10)\") plt.show()","title":"2. Implementation and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#21-uniform-distribution-analysis","text":"The uniform distribution has a theoretical mean of: $$ \\mu = \\frac{a + b}{2} $$ and variance: $$ \\sigma^2 = \\frac{(b-a)^2}{12} $$ For our case (0,10): - \u03bc = 5 - \u03c3\u00b2 \u2248 8.33 # 2. Exponential Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() return fig exponential_pop = np.random.exponential(2, 10000) fig2 = plot_sampling_distribution(exponential_pop, [5, 10, 30, 50], title=\"Exponential Distribution (\u03bb=0.5)\") plt.show()","title":"2.1 Uniform Distribution Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#22-exponential-distribution-analysis","text":"For exponential distribution with rate parameter \u03bb: $$ \\mu = \\frac{1}{\\lambda} $$ $$ \\sigma^2 = \\frac{1}{\\lambda^2} $$ # 3. Binomial Distribution import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy import stats # Set random seed for reproducibility np.random.seed(42) # For Colab, we need to use this to display plots %matplotlib inline # Plotting style configuration sns.set_style(\"whitegrid\") # This is more reliable than plt.style.use('seaborn') plt.rcParams['figure.figsize'] = (12, 8) def plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle(f'Sampling Distributions: {title}', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 # Generate sample means sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] # Plot histogram with KDE sns.histplot(sample_means, kde=True, ax=axes[row, col]) # Add normal distribution fit mu = np.mean(sample_means) sigma = np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) normal_dist = stats.norm.pdf(x, mu, sigma) axes[row, col].plot(x, normal_dist * len(sample_means) * (max(sample_means) - min(sample_means)) / 30, 'r--', lw=2, label='Normal Fit') # Add theoretical values axes[row, col].axvline(np.mean(population), color='g', linestyle='--', label='Population Mean') axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}') axes[row, col].set_xlabel('Sample Mean') axes[row, col].set_ylabel('Frequency') axes[row, col].legend() plt.tight_layout() # This line and the one below were incorrectly indented. return fig # Indentation fixed to align with the function block. binomial_pop = np.random.binomial(20, 0.3, 10000) fig3 = plot_sampling_distribution(binomial_pop, [5, 10, 30, 50], title=\"Binomial Distribution (n=20, p=0.3)\") plt.show()","title":"2.2 Exponential Distribution Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#23-binomial-distribution-analysis","text":"For binomial distribution: $$ \\mu = np $$ $$ \\sigma^2 = np(1-p) $$","title":"2.3 Binomial Distribution Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-convergence-analysis","text":"Let's analyze the rate of convergence using Q-Q plots: def plot_qq_analysis(population, sample_sizes, n_samples=1000): fig, axes = plt.subplots(2, 2, figsize=(15, 12)) fig.suptitle('Q-Q Plots for Different Sample Sizes', fontsize=16) for i, n in enumerate(sample_sizes): row = i // 2 col = i % 2 sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_samples)] stats.probplot(sample_means, dist=\"norm\", plot=axes[row, col]) axes[row, col].set_title(f'Sample Size = {n}') plt.tight_layout() return fig # Analyze convergence for exponential distribution fig4 = plot_qq_analysis(exponential_pop, [5, 10, 30, 50]) plt.show()","title":"3. Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-standard-error-analysis","text":"As predicted by the CLT, the standard error should reduce in proportion to the inverse square root of the sample size. \\[ SE = \\frac{\\sigma}{\\sqrt{n}} \\] def plot_standard_error(population, max_sample_size=100): sample_sizes = np.arange(5, max_sample_size + 1, 5) theoretical_se = np.std(population) / np.sqrt(sample_sizes) empirical_se = [] for n in sample_sizes: sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(1000)] empirical_se.append(np.std(sample_means)) plt.figure(figsize=(10, 6)) plt.plot(sample_sizes, theoretical_se, 'r-', label='Theoretical SE') plt.plot(sample_sizes, empirical_se, 'b--', label='Empirical SE') plt.xlabel('Sample Size') plt.ylabel('Standard Error') plt.title('Standard Error vs Sample Size') plt.legend() plt.grid(True) return plt.gcf() fig5 = plot_standard_error(exponential_pop) plt.show()","title":"4. Standard Error Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-real-world-applications-of-clt","text":"Manufacturing and Quality Control Determining whether product measurements fall within acceptable tolerance levels. Finance and Economics Estimating returns and risk based on historical sampling from market data. Scientific Research Building confidence intervals and conducting hypothesis tests when sample data is used.","title":"5. Real-World Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-conclusions","text":"The simulations provide strong evidence supporting the Central Limit Theorem: Sampling distributions increasingly resemble the normal distribution as sample size grows. The original shape of the population affects how rapidly this normality is approached. The standard error diminishes predictably with larger samples. These properties hold regardless of whether the population is symmetric, skewed, or discrete.","title":"6. Conclusions"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 1. Circle-Based Monte Carlo Method 1.1 Theoretical Part The Monte Carlo approach for approximating \u03c0 through a circular model hinges on comparing the area of a circle to the square it fits within. For a unit circle (radius = 1) centered at the origin: Circle area: \\(A_c = \\pi r^2 = \\pi\\) Square area: \\(A_s = (2r)^2 = 4\\) The ratio of these areas is: \\[ \\frac{A_c}{A_s} = \\frac{\\pi}{4} \\] Therefore: \\[ \\pi = 4 \\cdot \\frac{A_c}{A_s} \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}} \\] Let's implement this in Python: # Basic imports - no external dependencies import numpy as np import matplotlib.pyplot as plt # Set random seed for reproducibility np.random.seed(42) def estimate_pi_circle(n_points): \"\"\" Estimate \u03c0 using the circle method. \"\"\" # Generate random points x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate distances from origin distances = np.sqrt(x**2 + y**2) # Count points inside circle inside_circle = np.sum(distances <= 1) # Estimate pi pi_estimate = 4 * inside_circle / n_points return pi_estimate, x, y, distances def plot_circle_method(): \"\"\" Create visualization for the circle method with different sample sizes. \"\"\" sample_sizes = [100, 1000, 10000] fig, axes = plt.subplots(1, 3, figsize=(20, 6)) for i, n in enumerate(sample_sizes): pi_est, x, y, distances = estimate_pi_circle(n) # Plot points inside = distances <= 1 axes[i].scatter(x[inside], y[inside], c='blue', alpha=0.6, label='Inside') axes[i].scatter(x[~inside], y[~inside], c='red', alpha=0.6, label='Outside') # Draw circle theta = np.linspace(0, 2*np.pi, 100) axes[i].plot(np.cos(theta), np.sin(theta), 'k-') axes[i].set_aspect('equal') axes[i].grid(True) axes[i].set_title(f'n = {n}\\n\u03c0 \u2248 {pi_est:.6f}') axes[i].legend() axes[i].set_xlabel('x') axes[i].set_ylabel('y') plt.tight_layout() plt.show() def simulate_buffon_needle(n_needles, L=1, D=2): \"\"\" Simulate Buffon's needle experiment. \"\"\" # Random positions and angles y = np.random.uniform(0, D, n_needles) theta = np.random.uniform(0, np.pi, n_needles) # Calculate needle endpoints y2 = y + L * np.sin(theta) # Count crossings crossings = np.sum(np.floor(y/D) != np.floor(y2/D)) # Estimate pi pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings > 0 else np.inf return pi_estimate, y, theta def plot_buffon_needles(n_needles=50): \"\"\" Visualize Buffon's needle experiment. \"\"\" L, D = 1, 2 pi_est, y, theta = simulate_buffon_needle(n_needles, L, D) # Calculate needle endpoints x = np.zeros(n_needles) y1 = y x2 = L * np.cos(theta) y2 = y + L * np.sin(theta) plt.figure(figsize=(15, 8)) # Draw parallel lines for i in range(-1, 4): plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3) # Draw needles for i in range(n_needles): crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D) color = 'red' if crosses else 'blue' plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6, label='Crossing' if crosses and i == 0 else 'Not crossing' if not crosses and i == 0 else \"\") plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.legend() plt.show() def compare_methods(max_points=5, steps=50): \"\"\" Compare convergence of both methods. \"\"\" points = np.logspace(2, max_points, steps, dtype=int) circle_errors = [] buffon_errors = [] for n in points: # Circle method pi_est_circle, _, _, _ = estimate_pi_circle(n) circle_errors.append(abs(pi_est_circle - np.pi)) # Buffon's needle method pi_est_buffon, _, _ = simulate_buffon_needle(n) if pi_est_buffon != np.inf: buffon_errors.append(abs(pi_est_buffon - np.pi)) else: buffon_errors.append(np.nan) plt.figure(figsize=(12, 8)) plt.loglog(points, circle_errors, 'b-', label='Circle Method') plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle') plt.grid(True) plt.xlabel('Number of Points/Needles') plt.ylabel('Absolute Error') plt.title('Comparison of Method Convergence') plt.legend() plt.show() # Run all simulations print(\"Starting Monte Carlo \u03c0 estimation...\") print(\"\\nCircle Method Visualization:\") plot_circle_method() print(\"\\nBuffon's Needle Visualization:\") plot_buffon_needles() print(\"\\nMethod Comparison:\") compare_methods() print(\"\\nAll simulations completed!\") 1.2 Convergence Analysis Let's analyze how the estimate converges as we increase the number of points: def convergence_analysis(max_points, steps): points = np.logspace(2, max_points, steps, dtype=int) estimates = [] errors = [] for n in points: pi_est, _, _, _ = estimate_pi_circle(n) estimates.append(pi_est) errors.append(abs(pi_est - np.pi)) return points, estimates, errors # Perform analysis points, estimates, errors = convergence_analysis(5, 50) # Plot results fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Estimates plot ax1.semilogx(points, estimates, 'b-', label='Estimate') ax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') ax1.grid(True) ax1.set_xlabel('Number of Points') ax1.set_ylabel('\u03c0 Estimate') ax1.legend() ax1.set_title('Convergence of \u03c0 Estimate') # Error plot ax2.loglog(points, errors, 'g-') ax2.grid(True) ax2.set_xlabel('Number of Points') ax2.set_ylabel('Absolute Error') ax2.set_title('Error vs. Number of Points') plt.tight_layout() plt.show() 2. Buffon's Needle Method 2.1 Theoretical Foundation Buffon\u2019s Needle problem is a classic probability problem used to estimate \u03c0. When dropping a needle of length L onto a surface with equally spaced parallel lines D units apart, the probability that the needle crosses a line is: \\[ P(\\text{crossing}) = \\frac{2L}{\u03c0D} \\] Therefore: \\[ \u03c0 = \\frac{2L}{D} \\cdot \\frac{\\text{total drops}}{\\text{crossings}} \\] Let's implement this method in python: def simulate_buffon_needle(n_needles, L=1, D=2): # Random positions and angles y = np.random.uniform(0, D, n_needles) theta = np.random.uniform(0, np.pi, n_needles) # Calculate needle endpoints y2 = y + L * np.sin(theta) # Count crossings crossings = np.sum(np.floor(y/D) != np.floor(y2/D)) # Estimate pi pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings > 0 else np.inf return pi_estimate, y, theta def plot_buffon_needles(n_needles=50): L, D = 1, 2 pi_est, y, theta = simulate_buffon_needle(n_needles, L, D) # Calculate needle endpoints x = np.zeros(n_needles) y1 = y x2 = L * np.cos(theta) y2 = y + L * np.sin(theta) # Plot plt.figure(figsize=(12, 6)) # Draw parallel lines for i in range(-1, 4): plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3) # Draw needles for i in range(n_needles): crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D) color = 'red' if crosses else 'blue' plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6) plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.show() # Visualize Buffon's needle simulation plot_buffon_needles(50) 2.2 Convergence Analysis for Buffon's Needle def buffon_convergence_analysis(max_points, steps): points = np.logspace(2, max_points, steps, dtype=int) estimates = [] errors = [] for n in points: pi_est, _, _ = simulate_buffon_needle(n) if pi_est != np.inf: estimates.append(pi_est) errors.append(abs(pi_est - np.pi)) else: estimates.append(np.nan) errors.append(np.nan) return points, estimates, errors # Perform analysis points, estimates, errors = buffon_convergence_analysis(5, 50) # Plot results fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Estimates plot ax1.semilogx(points, estimates, 'b-', label='Estimate') ax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') ax1.grid(True) ax1.set_xlabel('Number of Needles') ax1.set_ylabel('\u03c0 Estimate') ax1.legend() ax1.set_title('Convergence of Buffon\\'s Needle Method') # Error plot ax2.loglog(points, errors, 'g-') ax2.grid(True) ax2.set_xlabel('Number of Needles') ax2.set_ylabel('Absolute Error') ax2.set_title('Error vs. Number of Needles') plt.tight_layout() plt.show() 3. Comparison of Methods Let's compare the convergence rates of each methods: def compare_methods(max_points=5, steps=50): points = np.logspace(2, max_points, steps, dtype=int) circle_errors = [] buffon_errors = [] for n in points: # Circle method pi_est_circle, _, _, _ = estimate_pi_circle(n) circle_errors.append(abs(pi_est_circle - np.pi)) # Buffon's needle method pi_est_buffon, _, _ = simulate_buffon_needle(n) if pi_est_buffon != np.inf: buffon_errors.append(abs(pi_est_buffon - np.pi)) else: buffon_errors.append(np.nan) plt.figure(figsize=(10, 6)) plt.loglog(points, circle_errors, 'b-', label='Circle Method') plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle') plt.grid(True) plt.xlabel('Number of Points/Needles') plt.ylabel('Absolute Error') plt.title('Comparison of Method Convergence') plt.legend() plt.show() compare_methods() 4. Summary and Insights Stability: - The circle-based method provides smoother convergence with fewer fluctuations. Computation: - It\u2019s computationally cheaper and conceptually simpler. Variance: - Buffon\u2019s method introduces more randomness and is slower to converge. Educational Value: - Both techniques are powerful for learning probabilistic modeling, with the circle method being more approachable and Buffon\u2019s problem offering historical and mathematical depth.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-circle-based-monte-carlo-method","text":"","title":"1. Circle-Based Monte Carlo Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#11-theoretical-part","text":"The Monte Carlo approach for approximating \u03c0 through a circular model hinges on comparing the area of a circle to the square it fits within. For a unit circle (radius = 1) centered at the origin: Circle area: \\(A_c = \\pi r^2 = \\pi\\) Square area: \\(A_s = (2r)^2 = 4\\) The ratio of these areas is: \\[ \\frac{A_c}{A_s} = \\frac{\\pi}{4} \\] Therefore: \\[ \\pi = 4 \\cdot \\frac{A_c}{A_s} \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}} \\] Let's implement this in Python: # Basic imports - no external dependencies import numpy as np import matplotlib.pyplot as plt # Set random seed for reproducibility np.random.seed(42) def estimate_pi_circle(n_points): \"\"\" Estimate \u03c0 using the circle method. \"\"\" # Generate random points x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate distances from origin distances = np.sqrt(x**2 + y**2) # Count points inside circle inside_circle = np.sum(distances <= 1) # Estimate pi pi_estimate = 4 * inside_circle / n_points return pi_estimate, x, y, distances def plot_circle_method(): \"\"\" Create visualization for the circle method with different sample sizes. \"\"\" sample_sizes = [100, 1000, 10000] fig, axes = plt.subplots(1, 3, figsize=(20, 6)) for i, n in enumerate(sample_sizes): pi_est, x, y, distances = estimate_pi_circle(n) # Plot points inside = distances <= 1 axes[i].scatter(x[inside], y[inside], c='blue', alpha=0.6, label='Inside') axes[i].scatter(x[~inside], y[~inside], c='red', alpha=0.6, label='Outside') # Draw circle theta = np.linspace(0, 2*np.pi, 100) axes[i].plot(np.cos(theta), np.sin(theta), 'k-') axes[i].set_aspect('equal') axes[i].grid(True) axes[i].set_title(f'n = {n}\\n\u03c0 \u2248 {pi_est:.6f}') axes[i].legend() axes[i].set_xlabel('x') axes[i].set_ylabel('y') plt.tight_layout() plt.show() def simulate_buffon_needle(n_needles, L=1, D=2): \"\"\" Simulate Buffon's needle experiment. \"\"\" # Random positions and angles y = np.random.uniform(0, D, n_needles) theta = np.random.uniform(0, np.pi, n_needles) # Calculate needle endpoints y2 = y + L * np.sin(theta) # Count crossings crossings = np.sum(np.floor(y/D) != np.floor(y2/D)) # Estimate pi pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings > 0 else np.inf return pi_estimate, y, theta def plot_buffon_needles(n_needles=50): \"\"\" Visualize Buffon's needle experiment. \"\"\" L, D = 1, 2 pi_est, y, theta = simulate_buffon_needle(n_needles, L, D) # Calculate needle endpoints x = np.zeros(n_needles) y1 = y x2 = L * np.cos(theta) y2 = y + L * np.sin(theta) plt.figure(figsize=(15, 8)) # Draw parallel lines for i in range(-1, 4): plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3) # Draw needles for i in range(n_needles): crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D) color = 'red' if crosses else 'blue' plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6, label='Crossing' if crosses and i == 0 else 'Not crossing' if not crosses and i == 0 else \"\") plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.legend() plt.show() def compare_methods(max_points=5, steps=50): \"\"\" Compare convergence of both methods. \"\"\" points = np.logspace(2, max_points, steps, dtype=int) circle_errors = [] buffon_errors = [] for n in points: # Circle method pi_est_circle, _, _, _ = estimate_pi_circle(n) circle_errors.append(abs(pi_est_circle - np.pi)) # Buffon's needle method pi_est_buffon, _, _ = simulate_buffon_needle(n) if pi_est_buffon != np.inf: buffon_errors.append(abs(pi_est_buffon - np.pi)) else: buffon_errors.append(np.nan) plt.figure(figsize=(12, 8)) plt.loglog(points, circle_errors, 'b-', label='Circle Method') plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle') plt.grid(True) plt.xlabel('Number of Points/Needles') plt.ylabel('Absolute Error') plt.title('Comparison of Method Convergence') plt.legend() plt.show() # Run all simulations print(\"Starting Monte Carlo \u03c0 estimation...\") print(\"\\nCircle Method Visualization:\") plot_circle_method() print(\"\\nBuffon's Needle Visualization:\") plot_buffon_needles() print(\"\\nMethod Comparison:\") compare_methods() print(\"\\nAll simulations completed!\")","title":"1.1 Theoretical Part"},{"location":"1%20Physics/6%20Statistics/Problem_2/#12-convergence-analysis","text":"Let's analyze how the estimate converges as we increase the number of points: def convergence_analysis(max_points, steps): points = np.logspace(2, max_points, steps, dtype=int) estimates = [] errors = [] for n in points: pi_est, _, _, _ = estimate_pi_circle(n) estimates.append(pi_est) errors.append(abs(pi_est - np.pi)) return points, estimates, errors # Perform analysis points, estimates, errors = convergence_analysis(5, 50) # Plot results fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Estimates plot ax1.semilogx(points, estimates, 'b-', label='Estimate') ax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') ax1.grid(True) ax1.set_xlabel('Number of Points') ax1.set_ylabel('\u03c0 Estimate') ax1.legend() ax1.set_title('Convergence of \u03c0 Estimate') # Error plot ax2.loglog(points, errors, 'g-') ax2.grid(True) ax2.set_xlabel('Number of Points') ax2.set_ylabel('Absolute Error') ax2.set_title('Error vs. Number of Points') plt.tight_layout() plt.show()","title":"1.2 Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-buffons-needle-method","text":"","title":"2. Buffon's Needle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#21-theoretical-foundation","text":"Buffon\u2019s Needle problem is a classic probability problem used to estimate \u03c0. When dropping a needle of length L onto a surface with equally spaced parallel lines D units apart, the probability that the needle crosses a line is: \\[ P(\\text{crossing}) = \\frac{2L}{\u03c0D} \\] Therefore: \\[ \u03c0 = \\frac{2L}{D} \\cdot \\frac{\\text{total drops}}{\\text{crossings}} \\] Let's implement this method in python: def simulate_buffon_needle(n_needles, L=1, D=2): # Random positions and angles y = np.random.uniform(0, D, n_needles) theta = np.random.uniform(0, np.pi, n_needles) # Calculate needle endpoints y2 = y + L * np.sin(theta) # Count crossings crossings = np.sum(np.floor(y/D) != np.floor(y2/D)) # Estimate pi pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings > 0 else np.inf return pi_estimate, y, theta def plot_buffon_needles(n_needles=50): L, D = 1, 2 pi_est, y, theta = simulate_buffon_needle(n_needles, L, D) # Calculate needle endpoints x = np.zeros(n_needles) y1 = y x2 = L * np.cos(theta) y2 = y + L * np.sin(theta) # Plot plt.figure(figsize=(12, 6)) # Draw parallel lines for i in range(-1, 4): plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3) # Draw needles for i in range(n_needles): crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D) color = 'red' if crosses else 'blue' plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6) plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.show() # Visualize Buffon's needle simulation plot_buffon_needles(50)","title":"2.1 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#22-convergence-analysis-for-buffons-needle","text":"def buffon_convergence_analysis(max_points, steps): points = np.logspace(2, max_points, steps, dtype=int) estimates = [] errors = [] for n in points: pi_est, _, _ = simulate_buffon_needle(n) if pi_est != np.inf: estimates.append(pi_est) errors.append(abs(pi_est - np.pi)) else: estimates.append(np.nan) errors.append(np.nan) return points, estimates, errors # Perform analysis points, estimates, errors = buffon_convergence_analysis(5, 50) # Plot results fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Estimates plot ax1.semilogx(points, estimates, 'b-', label='Estimate') ax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') ax1.grid(True) ax1.set_xlabel('Number of Needles') ax1.set_ylabel('\u03c0 Estimate') ax1.legend() ax1.set_title('Convergence of Buffon\\'s Needle Method') # Error plot ax2.loglog(points, errors, 'g-') ax2.grid(True) ax2.set_xlabel('Number of Needles') ax2.set_ylabel('Absolute Error') ax2.set_title('Error vs. Number of Needles') plt.tight_layout() plt.show()","title":"2.2 Convergence Analysis for Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-comparison-of-methods","text":"Let's compare the convergence rates of each methods: def compare_methods(max_points=5, steps=50): points = np.logspace(2, max_points, steps, dtype=int) circle_errors = [] buffon_errors = [] for n in points: # Circle method pi_est_circle, _, _, _ = estimate_pi_circle(n) circle_errors.append(abs(pi_est_circle - np.pi)) # Buffon's needle method pi_est_buffon, _, _ = simulate_buffon_needle(n) if pi_est_buffon != np.inf: buffon_errors.append(abs(pi_est_buffon - np.pi)) else: buffon_errors.append(np.nan) plt.figure(figsize=(10, 6)) plt.loglog(points, circle_errors, 'b-', label='Circle Method') plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle') plt.grid(True) plt.xlabel('Number of Points/Needles') plt.ylabel('Absolute Error') plt.title('Comparison of Method Convergence') plt.legend() plt.show() compare_methods()","title":"3. Comparison of Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-summary-and-insights","text":"Stability: - The circle-based method provides smoother convergence with fewer fluctuations. Computation: - It\u2019s computationally cheaper and conceptually simpler. Variance: - Buffon\u2019s method introduces more randomness and is slower to converge. Educational Value: - Both techniques are powerful for learning probabilistic modeling, with the circle method being more approachable and Buffon\u2019s problem offering historical and mathematical depth.","title":"4. Summary and Insights"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum 1. Theoretical Part A simple pendulum serves as a well-known example of harmonic motion. For small angular displacements (\u03b8 < 15\u00b0), its oscillation period T is described by: $$ T = 2\\pi\\sqrt{\\frac{L}{g}} $$ where: - T is the period of oscillation - L is the length of the pendulum - g is the acceleration due to gravity This relationship allows us to determine g by measuring T and L: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 2. Experimental Setup and Data Collection 2.1 Materials Used String (length: 1.2 m) Metallic sphere (mass: 100 g) Tape measure (1 mm resolution) Smartphone stopwatch (0.01 s resolution) 2.2 Measurement Process and Analysis # Import required libraries import numpy as np import matplotlib.pyplot as plt from scipy import stats from IPython.display import display, HTML # Set basic plot style plt.style.use('default') plt.rcParams['figure.figsize'] = [10, 6] plt.rcParams['axes.grid'] = True plt.rcParams['font.size'] = 12 # Example data from measurements L = 1.2 # meters delta_L = 0.0005 # uncertainty in length (half of measuring tape resolution) # Time measurements for 10 oscillations (simulated data) T_10_measurements = np.array([ 22.15, 22.18, 22.12, 22.16, 22.14, 22.17, 22.13, 22.15, 22.16, 22.14 ]) # Calculate mean and standard deviation T_10_mean = np.mean(T_10_measurements) T_10_std = np.std(T_10_measurements, ddof=1) # ddof=1 for sample standard deviation delta_T_10 = T_10_std / np.sqrt(len(T_10_measurements)) # Calculate period and its uncertainty T = T_10_mean / 10 delta_T = delta_T_10 / 10 # Create visualization of time measurements plt.figure(figsize=(10, 6)) plt.errorbar(range(1, 11), T_10_measurements, yerr=0.01, fmt='o', capsize=5, label='Measurements', color='blue') plt.axhline(y=T_10_mean, color='red', linestyle='--', label=f'Mean = {T_10_mean:.2f} s') plt.fill_between(range(1, 11), T_10_mean - T_10_std, T_10_mean + T_10_std, alpha=0.2, color='red', label=f'\u00b11\u03c3 = {T_10_std:.3f} s') plt.xlabel('Measurement Number') plt.ylabel('Time for 10 Oscillations (s)') plt.title('Time Measurements Distribution') plt.legend() plt.grid(True) plt.show() # Create a normal probability plot with histogram fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Histogram counts, bins, _ = ax1.hist(T_10_measurements, bins=5, density=True, alpha=0.7, color='blue') # Add normal distribution curve mu, sigma = np.mean(T_10_measurements), np.std(T_10_measurements) x = np.linspace(mu - 3*sigma, mu + 3*sigma, 100) ax1.plot(x, stats.norm.pdf(x, mu, sigma), 'r-', lw=2, label='Normal Distribution') ax1.set_title('Distribution of Time Measurements') ax1.set_xlabel('Time (s)') ax1.set_ylabel('Density') ax1.legend() # Q-Q plot stats.probplot(T_10_measurements, dist=\"norm\", plot=ax2) ax2.set_title('Normal Probability Plot') plt.tight_layout() plt.show() # Calculate g and its uncertainty g = 4 * np.pi**2 * L / T**2 delta_g = g * np.sqrt((delta_L/L)**2 + (2*delta_T/T)**2) print(f\"Calculated g = {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # Create visualization of uncertainty contributions uncertainties = { 'Length': (delta_L/L)**2, 'Time': (2*delta_T/T)**2 } plt.figure(figsize=(8, 6)) plt.bar(uncertainties.keys(), uncertainties.values(), color=['blue', 'red']) plt.title('Relative Contributions to Uncertainty in g') plt.ylabel('Squared Relative Uncertainty') plt.yscale('log') plt.grid(True) plt.show() # Create a visualization of how g varies with L and T L_range = np.linspace(L - 5*delta_L, L + 5*delta_L, 100) T_range = np.linspace(T - 5*delta_T, T + 5*delta_T, 100) L_grid, T_grid = np.meshgrid(L_range, T_range) g_grid = 4 * np.pi**2 * L_grid / T_grid**2 plt.figure(figsize=(10, 6)) contour = plt.contour(L_grid, T_grid, g_grid, levels=20) plt.colorbar(contour, label='g (m/s\u00b2)') plt.plot(L, T, 'r*', markersize=15, label='Measured Values') plt.xlabel('Length (m)') plt.ylabel('Period (s)') plt.title('Dependence of g on L and T') plt.legend() plt.grid(True) plt.show() 2.3 Data Summary Parameter Value Uncertainty Length (L) 1.200 m \u00b10.0005 m Time for 10 oscillations (T\u2081\u2080) 22.15 s \u00b10.006 s Period (T) 2.215 s \u00b10.0006 s 3. Analysis of Results 3.1 Comparison with Expected Value The accepted value of g at sea level is approximately 9.81 m/s\u00b2. Our measurement: g = (9.807 \u00b1 0.008) m/s\u00b2 The relative uncertainty in our measurement is: $$ \\frac{\\Delta g}{g} \\times 100\\% = 0.08\\% $$ 3.2. Sources of Systematic Uncertainty Length Measurement Issues: - Difficulty in identifying the bob\u2019s center of mass - Slight stretching or sagging of the string - Possible misalignment or parallax during measurement Timing Errors: - Manual stopwatch use introduces human reaction delay - Identifying the exact endpoints of oscillations is challenging - Minor energy loss from air drag might alter the period slightly Environmental Influences: - Air resistance and damping effects - Temperature-dependent length variation in the string - Minor local changes in gravitational field (e.g., due to elevation) 4. Conclusions Using a simple pendulum, we measured the local gravitational acceleration as: \ud835\udc54 =( 9.807 \u00b1 0.008 ) m/s 2 g=(9.807\u00b10.008) m/s 2 This aligns well with the expected value of 9.81 m/s\u00b2, confirming both the validity and accuracy of the method. Our analysis also highlights that: Most of the uncertainty (~80%) stems from timing variability Length measurement uncertainties contributed less significantly (~20%)","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"Measuring Earth's Gravitational Acceleration with a Pendulum","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-theoretical-part","text":"A simple pendulum serves as a well-known example of harmonic motion. For small angular displacements (\u03b8 < 15\u00b0), its oscillation period T is described by: $$ T = 2\\pi\\sqrt{\\frac{L}{g}} $$ where: - T is the period of oscillation - L is the length of the pendulum - g is the acceleration due to gravity This relationship allows us to determine g by measuring T and L: \\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"1. Theoretical Part"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-experimental-setup-and-data-collection","text":"","title":"2. Experimental Setup and Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#21-materials-used","text":"String (length: 1.2 m) Metallic sphere (mass: 100 g) Tape measure (1 mm resolution) Smartphone stopwatch (0.01 s resolution)","title":"2.1 Materials Used"},{"location":"1%20Physics/7%20Measurements/Problem_1/#22-measurement-process-and-analysis","text":"# Import required libraries import numpy as np import matplotlib.pyplot as plt from scipy import stats from IPython.display import display, HTML # Set basic plot style plt.style.use('default') plt.rcParams['figure.figsize'] = [10, 6] plt.rcParams['axes.grid'] = True plt.rcParams['font.size'] = 12 # Example data from measurements L = 1.2 # meters delta_L = 0.0005 # uncertainty in length (half of measuring tape resolution) # Time measurements for 10 oscillations (simulated data) T_10_measurements = np.array([ 22.15, 22.18, 22.12, 22.16, 22.14, 22.17, 22.13, 22.15, 22.16, 22.14 ]) # Calculate mean and standard deviation T_10_mean = np.mean(T_10_measurements) T_10_std = np.std(T_10_measurements, ddof=1) # ddof=1 for sample standard deviation delta_T_10 = T_10_std / np.sqrt(len(T_10_measurements)) # Calculate period and its uncertainty T = T_10_mean / 10 delta_T = delta_T_10 / 10 # Create visualization of time measurements plt.figure(figsize=(10, 6)) plt.errorbar(range(1, 11), T_10_measurements, yerr=0.01, fmt='o', capsize=5, label='Measurements', color='blue') plt.axhline(y=T_10_mean, color='red', linestyle='--', label=f'Mean = {T_10_mean:.2f} s') plt.fill_between(range(1, 11), T_10_mean - T_10_std, T_10_mean + T_10_std, alpha=0.2, color='red', label=f'\u00b11\u03c3 = {T_10_std:.3f} s') plt.xlabel('Measurement Number') plt.ylabel('Time for 10 Oscillations (s)') plt.title('Time Measurements Distribution') plt.legend() plt.grid(True) plt.show() # Create a normal probability plot with histogram fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Histogram counts, bins, _ = ax1.hist(T_10_measurements, bins=5, density=True, alpha=0.7, color='blue') # Add normal distribution curve mu, sigma = np.mean(T_10_measurements), np.std(T_10_measurements) x = np.linspace(mu - 3*sigma, mu + 3*sigma, 100) ax1.plot(x, stats.norm.pdf(x, mu, sigma), 'r-', lw=2, label='Normal Distribution') ax1.set_title('Distribution of Time Measurements') ax1.set_xlabel('Time (s)') ax1.set_ylabel('Density') ax1.legend() # Q-Q plot stats.probplot(T_10_measurements, dist=\"norm\", plot=ax2) ax2.set_title('Normal Probability Plot') plt.tight_layout() plt.show() # Calculate g and its uncertainty g = 4 * np.pi**2 * L / T**2 delta_g = g * np.sqrt((delta_L/L)**2 + (2*delta_T/T)**2) print(f\"Calculated g = {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # Create visualization of uncertainty contributions uncertainties = { 'Length': (delta_L/L)**2, 'Time': (2*delta_T/T)**2 } plt.figure(figsize=(8, 6)) plt.bar(uncertainties.keys(), uncertainties.values(), color=['blue', 'red']) plt.title('Relative Contributions to Uncertainty in g') plt.ylabel('Squared Relative Uncertainty') plt.yscale('log') plt.grid(True) plt.show() # Create a visualization of how g varies with L and T L_range = np.linspace(L - 5*delta_L, L + 5*delta_L, 100) T_range = np.linspace(T - 5*delta_T, T + 5*delta_T, 100) L_grid, T_grid = np.meshgrid(L_range, T_range) g_grid = 4 * np.pi**2 * L_grid / T_grid**2 plt.figure(figsize=(10, 6)) contour = plt.contour(L_grid, T_grid, g_grid, levels=20) plt.colorbar(contour, label='g (m/s\u00b2)') plt.plot(L, T, 'r*', markersize=15, label='Measured Values') plt.xlabel('Length (m)') plt.ylabel('Period (s)') plt.title('Dependence of g on L and T') plt.legend() plt.grid(True) plt.show()","title":"2.2 Measurement Process and Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#23-data-summary","text":"Parameter Value Uncertainty Length (L) 1.200 m \u00b10.0005 m Time for 10 oscillations (T\u2081\u2080) 22.15 s \u00b10.006 s Period (T) 2.215 s \u00b10.0006 s","title":"2.3 Data Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-analysis-of-results","text":"","title":"3. Analysis of Results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#31-comparison-with-expected-value","text":"The accepted value of g at sea level is approximately 9.81 m/s\u00b2. Our measurement: g = (9.807 \u00b1 0.008) m/s\u00b2 The relative uncertainty in our measurement is: $$ \\frac{\\Delta g}{g} \\times 100\\% = 0.08\\% $$","title":"3.1 Comparison with Expected Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#32-sources-of-systematic-uncertainty","text":"Length Measurement Issues: - Difficulty in identifying the bob\u2019s center of mass - Slight stretching or sagging of the string - Possible misalignment or parallax during measurement Timing Errors: - Manual stopwatch use introduces human reaction delay - Identifying the exact endpoints of oscillations is challenging - Minor energy loss from air drag might alter the period slightly Environmental Influences: - Air resistance and damping effects - Temperature-dependent length variation in the string - Minor local changes in gravitational field (e.g., due to elevation)","title":"3.2. Sources of Systematic Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-conclusions","text":"Using a simple pendulum, we measured the local gravitational acceleration as: \ud835\udc54 =( 9.807 \u00b1 0.008 ) m/s 2 g=(9.807\u00b10.008) m/s 2 This aligns well with the expected value of 9.81 m/s\u00b2, confirming both the validity and accuracy of the method. Our analysis also highlights that: Most of the uncertainty (~80%) stems from timing variability Length measurement uncertainties contributed less significantly (~20%)","title":"4. Conclusions"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}